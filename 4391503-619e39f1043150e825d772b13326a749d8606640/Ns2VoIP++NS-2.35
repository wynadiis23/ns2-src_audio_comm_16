diff --git a/ns-2.35/Makefile.in b/ns-2.35/Makefile.in
index 2e6ff5f..65cd2e7 100644
--- a/ns-2.35/Makefile.in
+++ b/ns-2.35/Makefile.in
@@ -71,7 +71,7 @@ INCLUDES = \
   -I./diffusion3/lib/main -I./diffusion3/lib \
 	-I./diffusion3/lib/nr -I./diffusion3/ns \
 	-I./diffusion3/filter_core -I./asim/ -I./qs \
-	-I./diffserv -I./satellite \
+	-I./diffserv -I./satellite -I./voip \
 	-I./wpan
 
 
@@ -163,6 +163,14 @@ NS_TCL_LIB_STL = tcl/lib/ns-diffusion.tcl \
 
 OBJ_CC = \
 	tools/random.o tools/rng.o tools/ranvar.o common/misc.o common/timer-handler.o \
+	tools/e2et.o \
+	tools/e2em.o \
+	tools/fairness.o \
+	tools/timestamper.o \
+	tools/debug-tools.o \
+	common/t_timers.o \
+	common/tfunctor.o \
+	common/stat.o \
 	common/scheduler.o common/object.o common/packet.o \
 	common/ip.o routing/route.o common/connector.o common/ttl.o \
 	trace/trace.o trace/trace-ip.o \
@@ -215,6 +223,11 @@ OBJ_CC = \
         dccp/dccp_tcplike.o \
         dccp/dccp_tfrc.o \
 	tools/integrator.o tools/queue-monitor.o \
+	tools/e2et.o \
+	tools/e2em.o \
+	tools/fairness.o \
+	tools/timestamper.o \
+	tools/debug-tools.o \
 	tools/flowmon.o tools/loss-monitor.o \
 	queue/queue.o queue/drop-tail.o \
 	adc/simple-intserv-sched.o queue/red.o \
@@ -333,6 +346,17 @@ OBJ_CC = \
 	wpan/p802_15_4sscs.o wpan/p802_15_4timer.o \
 	wpan/p802_15_4trace.o wpan/p802_15_4transac.o \
 	apps/pbc.o \
+	voip/voip_bidirectional.o \
+	voip/voip_encoder.o \
+	voip/voip_decoder.o \
+	voip/voip_decoder_optimal.o \
+	voip/voip_decoder_static.o \
+	voip/voip_decoder_80216m.o \
+	voip/voip_decoder_h323.o \
+	voip/voip_decoder_atzori.o \
+        voip/voip_source.o \
+        voip/voip_aggregate.o \
+        voip/voip_header.o \
 	@V_STLOBJ@
 
 
diff --git a/ns-2.35/apps/udp.cc b/ns-2.35/apps/udp.cc
index 038704f..aa9fa9a 100644
--- a/ns-2.35/apps/udp.cc
+++ b/ns-2.35/apps/udp.cc
@@ -50,6 +50,7 @@ static const char rcsid[] =
 #include "address.h"
 #include "ip.h"
 
+#include <stat.h> 
 
 static class UdpAgentClass : public TclClass {
 public:
@@ -73,12 +74,13 @@ UdpAgent::UdpAgent(packet_t type) : Agent(type)
 // have one.
 void UdpAgent::sendmsg(int nbytes, AppData* data, const char* flags)
 {
-	Packet *p;
-	int n;
+	Packet* p = 0;
+        int n = 0;
 
 	assert (size_ > 0);
 
-	n = nbytes / size_;
+        n = 1 + (( nbytes - 1 ) / size_);
+        int ntot = n ;
 
 	if (nbytes == -1) {
 		printf("Error:  sendmsg() for UDP should not be -1\n");
@@ -91,33 +93,26 @@ void UdpAgent::sendmsg(int nbytes, AppData* data, const char* flags)
 		return;
 	}
 
-	double local_time = Scheduler::instance().clock();
-	while (n-- > 0) {
+	//double local_time = Scheduler::instance().clock();
+	while ( n > 0) {
 		p = allocpkt();
-		hdr_cmn::access(p)->size() = size_;
 		hdr_rtp* rh = hdr_rtp::access(p);
-		rh->flags() = 0;
-		rh->seqno() = ++seqno_;
-		hdr_cmn::access(p)->timestamp() = 
-		    (u_int32_t)(SAMPLERATE*local_time);
 		// add "beginning of talkspurt" labels (tcl/ex/test-rcvr.tcl)
-		if (flags && (0 ==strcmp(flags, "NEW_BURST")))
+		if (flags && (0 ==strcmp(flags, "NEW_BURST"))) {
 			rh->flags() |= RTP_M;
-		p->setdata(data);
-		target_->recv(p);
 	}
-	n = nbytes % size_;
-	if (n > 0) {
-		p = allocpkt();
-		hdr_cmn::access(p)->size() = n;
-		hdr_rtp* rh = hdr_rtp::access(p);
-		rh->flags() = 0;
-		rh->seqno() = ++seqno_;
-		hdr_cmn::access(p)->timestamp() = 
-		    (u_int32_t)(SAMPLERATE*local_time);
-		// add "beginning of talkspurt" labels (tcl/ex/test-rcvr.tcl)
-		if (flags && (0 == strcmp(flags, "NEW_BURST")))
+		if ( n > 1 ) {
+                        // non-last packet
+                        rh->flags() &= ~RTP_M;
+                        hdr_cmn::access(p)->size() = size_;
+                } else {
+                        // last packet
 			rh->flags() |= RTP_M;
+                        hdr_cmn::access(p)->size() = nbytes - ( ntot - 1 ) * size_;
+                }
+                n--;
+                rh->seqno() = ++seqno_;
+                hdr_cmn::access(p)->timestamp() = NOW;
 		p->setdata(data);
 		target_->recv(p);
 	}
diff --git a/ns-2.35/common/ns-process.h b/ns-2.35/common/ns-process.h
index 2ddd1dc..87829be 100644
--- a/ns-2.35/common/ns-process.h
+++ b/ns-2.35/common/ns-process.h
@@ -83,7 +83,8 @@ enum AppDataType {
 
 	// pub/sub ADU
 	PUBSUB,
-	
+	// VoIP DATA
+	VOIP_DATA,
 	//Diffusion ADU
 	DIFFUSION_DATA,
 
diff --git a/ns-2.35/common/packet.h b/ns-2.35/common/packet.h
index 31bc393..ad2386a 100644
--- a/ns-2.35/common/packet.h
+++ b/ns-2.35/common/packet.h
@@ -47,6 +47,9 @@
 #include "packet-stamp.h"
 #include "ns-process.h"
 
+// number of timestamps for each packet
+#define TSTAMP_NO 10
+
 // Used by wireless routing code to attach routing agent
 #define RT_PORT		255	/* port that all route msgs are sent to */
 
@@ -641,6 +644,16 @@ struct hdr_cmn {
 
 	// tx time for this packet in sec
 	double txtime_;
+		
+	// measure module start
+	double e2e_ts_[TSTAMP_NO];  // timestamp fore2e packet delay and jitter
+	int e2e_ts_no;              // the first empty timestamp (initially =0)
+	int e2e_sn_;                // Sequence number for e2e packet loss ratio
+	inline double& e2e_timestamp(int t) { return e2e_ts_[t]; }
+	inline int& e2e_timestamp_no() { return (e2e_ts_no); }
+	inline int& e2e_sn() {return e2e_sn_; }
+	// measure module end
+	
 	inline double& txtime() { return(txtime_); }
 
 	static int offset_;	// offset for this header
@@ -710,6 +723,7 @@ inline Packet* Packet::alloc()
 	init(p); // Initialize bits_[]
 	(HDR_CMN(p))->next_hop_ = -2; // -1 reserved for IP_BROADCAST
 	(HDR_CMN(p))->last_hop_ = -2; // -1 reserved for IP_BROADCAST
+	(HDR_CMN(p))->e2e_ts_no=-1; // no timestamp for a newly created packet
 	p->fflag_ = TRUE;
 	(HDR_CMN(p))->direction() = hdr_cmn::DOWN;
 	/* setting all direction of pkts to be downward as default; 
diff --git a/ns-2.35/common/simulator.cc b/ns-2.35/common/simulator.cc
index 04fd596..c711592 100644
--- a/ns-2.35/common/simulator.cc
+++ b/ns-2.35/common/simulator.cc
@@ -60,11 +60,27 @@ public:
 } simulator_class;
 
 Simulator* Simulator::instance_;
+unsigned int Simulator::run_ = 0;
 
 int Simulator::command(int argc, const char*const* argv) {
 	Tcl& tcl = Tcl::instance();
 	if ((instance_ == 0) || (instance_ != this))
 		instance_ = this;
+	// set the run identifier for the current run
+	// reset the substream index for the defaultRNG
+	if ( argc == 3 && strcmp(argv[1], "run-identifier") == 0 ) {
+		run_ = (unsigned)atoi(argv[2]);
+		for ( unsigned int i = 0 ; i < run_ ; i++ ) {
+		        RNG::defaultrng()->reset_next_substream();
+		}
+		return TCL_OK;
+	}
+	
+	// call Stat command functions
+	if ( argc >= 3 && strcmp(argv[1], "stat") == 0 ) {
+		return Stat::command (argc - 2, argv + 2);
+	}
+	
 	if (argc == 3) {
 		if (strcmp(argv[1], "populate-flat-classifiers") == 0) {
 			nn_ = atoi(argv[2]);
diff --git a/ns-2.35/common/simulator.h b/ns-2.35/common/simulator.h
index 390f156..fb776ce 100644
--- a/ns-2.35/common/simulator.h
+++ b/ns-2.35/common/simulator.h
@@ -53,6 +53,7 @@
 
 #include <tclcl.h>
 #include "object.h"
+#include <stat.h>
 
 class ParentNode;
 class RouteLogic;
@@ -75,6 +76,7 @@ public:
 	char *append_addr(int level, int *addr);
 	void alloc(int n);
 	void check(int n);
+	static unsigned int run () { return run_; }
 	
 private:
         ParentNode **nodelist_;
@@ -83,6 +85,7 @@ private:
 	int size_;
 	char macType_[SMALL_LEN];
 	static Simulator* instance_;
+	static unsigned int run_;
 };
 
 #endif /* ns_simulator_h */
diff --git a/ns-2.35/common/stat.cc b/ns-2.35/common/stat.cc
new file mode 100644
index 0000000..df3da65
--- /dev/null
+++ b/ns-2.35/common/stat.cc
@@ -0,0 +1,508 @@
+#include <stat.h>
+
+#include "object.h"
+#include "simulator.h"
+
+//! \todo just for test
+#include <iostream>
+
+/* ======================================================================
+   SamplesAverage Functions
+   ====================================================================== */
+
+SamplesAverage::SamplesAverage ()
+{
+	nsamples = 0;
+	sumS = 0;
+	minS = FP_NAN;
+	maxS = FP_NAN;
+}
+
+void
+SamplesAverage::add (double x)
+{
+	// update the min/max sample
+	minS = ( nsamples == 0 || x < minS ) ? x : minS;
+	maxS = ( nsamples == 0 || x > maxS ) ? x : maxS;
+
+	// update the number of samples
+	++nsamples;
+
+	// update the sum of samples
+	sumS += x;
+}
+
+/* ======================================================================
+   SamplesDist Functions
+   ====================================================================== */
+
+SamplesDist::SamplesDist ( unsigned int n, double l, double u )
+{
+	bucket = new double[n];
+	nbins = n;
+
+	lower = l;
+	upper = u;
+	size = ( upper - lower ) / double(nbins);
+
+	reset ();
+}
+
+void
+SamplesDist::reset ()
+{
+	n_underflow = 0;
+	n_overflow = 0;
+	nsamples = 0;
+	minS = FP_NAN;
+	maxS = FP_NAN;
+	for ( unsigned int i = 0 ; i < nbins ; i++ )
+		bucket[i] = 0;
+}
+
+void
+SamplesDist::add (double x, double y)
+{
+	// get the bucket index
+	int i = int ( ( x - lower ) / size );
+
+	if ( i >= 0 && i < (int) nbins )
+		bucket[i] += y;
+	else if ( i < 0 )
+		n_underflow += y;
+	else /* if ( i >= nbins ) */
+		n_overflow += y;
+
+	// update the minimum and maximum samples
+	minS = ( nsamples == 0 || x < minS ) ? x : minS;
+	maxS = ( nsamples == 0 || x > maxS ) ? x : maxS;
+
+	// update the number of samples
+	nsamples += y;
+}
+
+double
+SamplesDist::getValue (int i) const
+{
+	return lower + ( 1.0 + i ) * size;
+}
+
+double
+SamplesDist::mean () const
+{
+	double E = 0;
+	for ( unsigned int i = 0 ; i < nbins ; i++ )
+		E += getValue(i) * bucket[i];
+
+	return ( nsamples == 0 ) ? FP_NAN : ( E / nsamples );
+}
+
+/* ======================================================================
+   Stat Functions
+   ====================================================================== */
+
+Stat::Stat ()
+{
+	collect = false;
+	fileout = 0;
+}
+
+int Stat::command(int argc, const char*const* argv) {
+
+	// turn on statistics collection
+   if ( argc == 1 && strcmp (argv[0], "on") == 0 ) {
+		if ( collect == false ) {
+			collect = true;
+			enabled = Scheduler::instance().clock();
+		}
+		return 0;  // TCL_OK
+
+	// turn off statistics collection
+	} else if ( argc == 1 && strcmp (argv[0], "off") == 0 ) {
+		// ignore if statistics collection is already disabled
+		if ( collect == true ) {
+			collect  = false;
+			// update the run duration
+			duration += Scheduler::instance().clock() - enabled;
+		}
+		return 0; // TCL_OK
+
+	// print out collected statistics, if collection is enabled
+	} else if ( argc == 1 && strcmp (argv[0], "print") == 0 ) {
+		if ( initialized () == false )
+			return 1; // TCL_ERROR
+		if ( collect == true )  {
+			// update the run duration
+			duration += Scheduler::instance().clock() - enabled;
+			// print out data samples
+			print ();
+		}
+		return 0; // TCL_OK
+
+	// set the output file for statistics collection
+	// does *not* turn statistics collection on
+   } else if ( argc == 2 && strcmp (argv[0], "file") == 0 ) {
+		bool ret = initialize (argv[1]);
+		if ( ret == false ) return 1; // TCL_ERROR
+		return 0; // TCL_OK
+
+	// add a scalar metric
+	} else if ( argc == 4 && strcmp (argv[0], "add") == 0
+			&& strcmp (argv[2], "avg") == 0 ) {
+
+		stat_desc& desc = metrics[std::string(argv[1])];
+
+		desc.type = SCALAR;
+		desc.subtype =
+			( strcmp (argv[3], "rate") == 0 ) ? RATE :
+			( strcmp (argv[3], "continuous") == 0 ) ? CONTINUOUS :
+			( strcmp (argv[3], "discrete") == 0 ) ? DISCRETE :
+			( strcmp (argv[3], "counter") == 0 ) ? COUNTER : UNKNOWN;
+
+		if ( desc.subtype == UNKNOWN ) {
+			fprintf (stderr, "Unknown metric type '%s'\n", argv[3]);
+			return 1; // TCL_ERROR
+		}
+
+		return 0; // TCL_OK
+
+	// add a distribution metric
+	} else if ( argc == 7 && strcmp (argv[0], "add") == 0
+			&& strcmp (argv[2], "dst") == 0 ) {
+
+		stat_desc& desc = metrics[std::string(argv[1])];
+
+		desc.type = DISTRIBUTION;
+		desc.subtype =
+			( strcmp (argv[3], "rate") == 0 ) ? RATE :
+			( strcmp (argv[3], "continuous") == 0 ) ? CONTINUOUS :
+			( strcmp (argv[3], "discrete") == 0 ) ? DISCRETE : 
+			( strcmp (argv[3], "debug") == 0 ) ? COUNTER : UNKNOWN;
+		desc.lower = atof (argv[4]);
+		desc.upper = atof (argv[5]);
+		desc.nbins = atoi (argv[6]);
+
+		if ( desc.nbins <= 0 ) {
+			fprintf (stderr, "Metric '%s' has a negative number of bins %d\n",
+					argv[1], desc.nbins);
+			return 1; // TCL_ERROR
+		}
+
+		if ( desc.upper <= desc.lower ) {
+			fprintf (stderr,
+					"Metric '%s' has lower bound (%f) >= upper bound (%f)\n",
+					argv[1], desc.lower, desc.upper);
+			return 1; // TCL_ERROR
+		}
+
+		if ( desc.subtype == UNKNOWN || desc.subtype == COUNTER ) {
+			fprintf (stderr, "Unknown or invalid metric type '%s'\n", argv[3]);
+			return 1; // TCL_ERROR
+		}
+
+		return 0; // TCL_OK
+
+	// trace the samples of a flow
+	} else if ( argc == 4 && strcmp (argv[0], "trace") == 0 ) {
+
+		stat_desc& desc = metrics[std::string(argv[1])];
+
+		desc.trace[atoi(argv[2])] = fopen (argv[3], "w");
+		
+		if ( ! desc.trace[atoi(argv[2])] ) {
+			fprintf (stderr, "Could not open '%s' for writing\n", argv[3]);
+			return 1; // TCL_ERROR
+		}
+
+		return 0; // TCL_OK
+	}
+
+	fprintf (stderr, "invalid stat command: '");
+	for ( int i = 0 ; i < argc ; i++ ) fprintf (stderr, "%s ", argv[i]);
+	fprintf (stderr, "'\n");
+	
+	return 1; // TCL_ERROR
+}
+
+void Stat::reset ()
+{
+	// TODO
+	fprintf (stderr, "TODO\n");
+	abort ();
+}
+
+bool
+Stat::initialize (const char* filename)
+{
+	if ( fileout != 0 )
+		fclose (fileout);
+	fileout = fopen (filename, "w");
+	// metrics.set_empty_key (0);
+	return initialized();
+}
+
+double 
+Stat::get (const char* metric, const int ID)
+{
+        // silent return if we are not collecting samples right now
+        // or if we try to get a value of a non-initialized metric
+        if ( collect == false || metrics.count(std::string(metric)) == 0 ) {
+                return 0.0;
+        }
+        // Get the desciptor of the metric
+        stat_desc& desc = metrics[std::string(metric)];
+        // Get the descriptor of the measure
+        typedef std::map<int, meas_descriptor>::const_iterator CI;
+        CI p = desc.metrics.find(ID);
+        // Check if the metrics exists
+        if ( p == desc.metrics.end() ) {
+                // The measure for the given ID has not been found
+                return 0.0;
+        }
+        const meas_descriptor& meas = p->second;
+        const SamplesAverage* const avg = meas.average;
+        // Get the current measure value
+        double x = 0.0;
+        if ( desc.subtype == RATE ) {
+                if ( avg->n() != 0 && duration > 0 ) x = avg->sum() / duration;
+        } else if ( desc.subtype == CONTINUOUS ) {
+                if ( avg->n() > 1 ) x = avg->sum() / meas.sumTimes;
+        } else if ( desc.subtype == DISCRETE ) {
+                if ( avg->n() != 0 ) x = avg->mean();
+        } else if ( desc.subtype == COUNTER ) {
+                if ( avg->n() != 0 ) x = avg->sum();
+        }
+        return x;
+}
+
+void
+Stat::put (const char* metric, int ID, double x)
+{
+	// silent return if we are not collecting samples right now
+	// or if we try to add a sample to a non-initialized metric
+	if ( collect == false || metrics.count(std::string(metric)) == 0 ) return;
+
+	stat_desc& desc = metrics[std::string(metric)];
+
+	// print samples to an output trace file, if needed
+	FileMap::iterator it = desc.trace.find (ID);
+	if ( it != desc.trace.end() ) fprintf (it->second, "%f %f\n", NOW, x);
+
+	meas_descriptor& meas = desc.metrics[ID];
+
+	if ( desc.type == SCALAR ) {
+
+		// check if the SamplesAverage object has been already initialized
+		if ( ! meas.average ) meas.average = new SamplesAverage;
+
+		// update the samples field, according to the metric subtype
+		if ( desc.subtype == RATE ) {
+			meas.average->add (x);
+		} else if ( desc.subtype == CONTINUOUS ) {
+			double& last = meas.lastTime; // alias
+			if ( last >= 0.0 ) { 
+				meas.average->add ( x * ( NOW - last) );
+				meas.sumTimes += (NOW - last );
+			}
+			last = NOW;
+		} else if ( desc.subtype == DISCRETE ) {
+			meas.average->add (x);
+		} else if ( desc.subtype == COUNTER ) {
+			meas.average->add (x);
+		} else {
+			// there are not any other averaged metric subtypes
+			abort ();
+		}
+
+	} else {
+		// check if the SamplesAverage object has been already initialized
+		if ( ! meas.distribution ) meas.distribution =
+			new SamplesDist ( desc.nbins, desc.lower, desc.upper );
+
+		// update the samples field, according to the metric subtype
+		if ( desc.subtype == RATE ) {
+			meas.distribution->add (x);
+		} else if ( desc.subtype == CONTINUOUS ) {
+			double& last = meas.lastTime; // alias
+			if ( last >= 0.0 ) { 
+				meas.distribution->add ( x, NOW - last );
+				meas.sumTimes += (NOW - last );
+			}
+			last = NOW;
+		} else if ( desc.subtype == DISCRETE ) {
+			meas.distribution->add (x);
+		} else {
+			// there are not any other averaged metric subtypes
+			abort ();
+		}
+	}
+
+}
+
+void 
+Stat::addPostProcessMetric(TFunctor* functor)
+{
+        postProcessingFunctions_.push_back(functor);
+}
+
+void
+Stat::computeAggregateStatistics() 
+{
+        // Alias
+        typedef std::list< TFunctor* >::const_iterator CI;
+        // Inkove the callback functions to compute aggregate metrics
+        CI p = postProcessingFunctions_.begin();
+        while ( p != postProcessingFunctions_.end() ) {
+                // Invoke the callback function
+                (*p)->call();
+                // Get the next function
+                p++;
+        }
+}
+
+void
+Stat::print ()
+{
+	DescMap::iterator it;
+	MeasMap::iterator jt;
+
+	if ( ! initialized () ) return;
+
+	//
+	// count the number of scalar and distribution metrics, respectively
+	//
+	
+	// Rev. 20070414 Andrea
+	// cerr << "Stat.cc: Processing composite statistics" << endl;
+	// cerr << "This statistics are based on a combination of primitive statistics" << endl;
+	computeAggregateStatistics();
+
+	unsigned int nscalar = 0;
+	unsigned int ndistribution = 0;
+
+	for ( it = metrics.begin() ; it != metrics.end() ; ++it ) {
+		if ( it->second.metrics.size() == 0 ) continue;
+		if ( it->second.type == SCALAR ) ++nscalar;
+		else ++ndistribution;
+	}
+
+	//
+	// print data to the output file
+	//
+
+	// get the run identifier from the Simulator object
+	unsigned int run = Simulator::run();
+
+	// run ID
+	fwrite (&run, sizeof(run), 1, fileout);
+
+	// print the number of scalar metrics
+	fwrite (&nscalar, sizeof(nscalar), 1, fileout);
+
+	// exit when all the metrics have been printed out
+	for ( it = metrics.begin() ; it != metrics.end() ; ++it ) {
+		stat_desc* p = &(it->second); // alias
+		const char* name = it->first.c_str(); // alias
+		
+		// skip any metric which does not have any samples or is a distribution
+		if ( p->metrics.size() == 0 || p->type == DISTRIBUTION ) continue;
+
+		// count the number of meaningful metrics
+		// i.e. the CUMULATIVE and AVERAGE ones with at least one sample
+		// and the TIME metrics with at least two samples
+		// The COUNTER metrics are reported even if the number of samples
+		// is zero.
+		unsigned int how_many = 0;
+		for ( jt = p->metrics.begin() ; jt != p->metrics.end() ; ++jt ) {
+			SamplesAverage* avg = jt->second.average;
+			if ( p->subtype == RATE || p->subtype == DISCRETE || p->subtype == COUNTER) {
+				if ( avg->n() >= 1 ) how_many++;
+			} else if ( p->subtype == CONTINUOUS ) {
+				if ( avg->n() >= 2 ) how_many++;
+			} else {
+				// there is not other averaged metric subtype
+				abort ();
+			}
+		}
+		unsigned int len = strlen (name) + 1;
+
+		fwrite (&how_many, sizeof(how_many), 1, fileout);
+		fwrite (&len, sizeof(len), 1, fileout);
+		fwrite (name, len, 1, fileout);
+
+		for ( jt = p->metrics.begin() ; jt != p->metrics.end() ; ++jt ) {
+			SamplesAverage* avg = jt->second.average;
+			double x;
+			// average the samples over the run duration
+			if ( p->subtype == RATE ) {
+                                if ( avg->n() == 0 ) continue;
+				x = avg->sum() / duration;
+			} else if ( p->subtype == CONTINUOUS ) {
+			if ( avg->n() <= 1 ) continue;
+				x = avg->sum() / jt->second.sumTimes;
+			} else if ( p->subtype == DISCRETE ) {
+				if ( avg->n() == 0 ) continue;
+				x = avg->mean();
+			} else if ( p->subtype == COUNTER ) {
+				if ( avg->n() == 0 ) continue;
+				x = avg->sum();
+			}
+
+			fwrite (&jt->first, sizeof(jt->first), 1, fileout);
+			fwrite (&x, sizeof(x), 1, fileout);
+		}
+	}
+
+	// print the number of distribution metrics
+	fwrite (&ndistribution, sizeof(ndistribution), 1, fileout);
+
+	// print out all the remaining distribution metrics
+	for ( it = metrics.begin() ; it != metrics.end() ; ++it ) {
+		stat_desc* p = &(it->second); // alias
+		const char* name = it->first.c_str(); // alias
+		
+		// skip any metric which does not have any samples or is a scalar
+		if ( p->metrics.size() == 0 || p->type == SCALAR ) continue;
+
+		unsigned int ndx = 0;  // number of indices in this metric
+		for ( jt = p->metrics.begin() ; jt != p->metrics.end() ; ++jt ) {
+			SamplesDist* dist = jt->second.distribution;
+			if ( ! dist->empty() > 0 ) ++ndx;
+		}
+
+		unsigned int len = strlen (name) + 1;
+		unsigned int nbins = p->nbins;
+		double binSize = ( p->upper - p->lower ) / (double)nbins;
+		double lowerBd = p->lower;
+
+		fwrite (&ndx, sizeof(ndx), 1, fileout);
+		fwrite (&len, sizeof(len), 1, fileout);
+		fwrite (name, len, 1, fileout);
+		fwrite (&binSize, sizeof(binSize), 1, fileout);
+		fwrite (&lowerBd, sizeof(lowerBd), 1, fileout);
+		fwrite (&nbins, sizeof(nbins), 1, fileout);
+		
+		for ( jt = p->metrics.begin() ; jt != p->metrics.end() ; ++jt ) {
+			SamplesDist* dist = jt->second.distribution;
+
+			if ( dist->empty() ) continue;
+
+			fwrite (&jt->first, sizeof(jt->first), 1, fileout);
+		  for ( unsigned int k = 0 ; k < nbins ; k++ ) {
+				double x = dist->getSamplesPerBin (k) / dist->n();
+				fwrite (&x, sizeof(x), 1, fileout);
+			}
+		}
+	}
+
+	fflush (fileout);
+}
+
+// static object & members initialization
+Stat Stat::stat;
+Stat::DescMap Stat::metrics;
+Stat::FunctionList Stat::postProcessingFunctions_;
+double Stat::duration = 0.0;
+double Stat::enabled = 0.0;
+bool Stat::collect = false;
+FILE* Stat::fileout = 0; 
diff --git a/ns-2.35/common/stat.h b/ns-2.35/common/stat.h
new file mode 100644
index 0000000..48447f8
--- /dev/null
+++ b/ns-2.35/common/stat.h
@@ -0,0 +1,314 @@
+/**
+   project: measure
+   filename: stat.cc
+   author: C. Cicconetti <c.cicconetti@iet.unipi.it>
+   year: 2006
+   affiliation:
+      Dipartimento di Ingegneria dell'Informazione
+      University of Pisa, Italy
+   description:
+      body of ns2 SamplesDist and Stat classes
+*/
+
+#ifndef ns_stat_h
+#define ns_stat_h
+
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+
+#include <tfunctor.h>
+#include <list>
+
+#include <map>
+#include <string>
+
+//#include <google/dense_hash_map>
+
+/* ======================================================================
+   SamplesAverage class
+   ====================================================================== */
+
+//! Samples average class.
+class SamplesAverage {
+	/*
+    * Public members.
+	 */
+public:
+	//! Build an empty SamplesAverage object.
+	SamplesAverage ();
+	//! Return the smallest sample.
+	double minSample () const { return minS; }
+	//! Return the largest sample.
+	double maxSample () const { return maxS; }
+	//! Return the avereage.
+	double mean () const { return sumS / nsamples; }
+	//! Return the sum of samples.
+	double sum () const { return sumS; }
+	//! Return the number of samples.
+	unsigned int n () const { return nsamples; }
+	//! Return true if no samples have been added.
+	bool empty () const { return ( nsamples == 0 ) ? true : false; }
+	//! Add a sample.
+	void add (double x);
+private:
+	//! Number of samples.
+	unsigned int nsamples;
+	//! Smallest sample.
+	double minS;
+	//! Largest sample.
+	double maxS;
+	//! Sum of samples.
+	double sumS;
+};
+
+/* ======================================================================
+   SamplesDist class
+   ====================================================================== */
+
+//! Samples distribution class.
+class SamplesDist {
+	/*
+    * Public members.
+	 */
+public:
+	//! Create an empty SamplesDist object.
+	SamplesDist ( unsigned int n = 0, double l = 0.0 , double u = 0.0 );
+
+	//! Reinitialize the object. Stored samples are dropped.
+	void initialize ( unsigned int n, double l, double u );
+	//! Clean all collected samples.
+	void reset ();
+
+	//! Add sample y to bin x.
+	void add ( double x, double y = 1.0 );
+
+	//! Get the minimum sample. If no samples => FP_NAN.
+	double minSample () const { return minS; }
+	//! Get the maximum sample. If no samples => FP_NAN.
+	double maxSample () const { return maxS; }
+	//! Get the samples mean. If no samples => FP_NAN.
+	double mean () const;
+
+	//! Return true if no samples have been added.
+	bool empty () const { return ( nsamples == 0 ) ? true : false; }
+	//! Get the number of samples.
+	double n () const { return nsamples; }
+
+	//! Return the number of underflow samples.
+	double underflow () const { return n_underflow; }
+	//! Return the number of overflow samples.
+	double overflow () const { return n_overflow; }
+	//! Return the bin size.
+	double bin_size () const { return size; }
+	//! Return the number of bins.
+	unsigned int getNBins () const { return nbins; }
+
+	//! Return the number of samples in a bin.
+	double getSamplesPerBin (unsigned int i) const { return bucket[i]; }
+
+	/*
+    * Private members.
+	 */
+private:
+	//! Copy construction forbidden.
+	SamplesDist (const SamplesDist&);
+	//! Assignment forbidden.
+	const SamplesDist& operator= (const SamplesDist&);
+
+	//! Return the upper bound of the i-th bucket.
+	double getValue (int i) const;
+
+	/*
+    * Data structure.
+	 */
+private:
+	//! Buckets of samples.
+	/*!
+	  Each bucket i stores the number of samples falling into the interval
+	     [lower + i * size, lower + (i+1) * size)
+	  where size is ( ( upper - lower ) / N_BUCKETS ).
+	  Samples falling behind this interval are dropped.
+	  */
+	double* bucket;
+	//! Number of bins.
+	unsigned int nbins;
+	//! Lower bound of the samples to collect.
+	double lower;
+	//! Upper bound of the samples to collect.
+	double upper;
+	//! Number of underflow samples.
+	double n_underflow;
+	//! Number of overflow samples.
+	double n_overflow;
+	//! Bucket size.
+	double size;
+	//! Smallest sample.
+	double minS;
+	//! Largest sample.
+	double maxS;
+	//! Number of samples.
+	double nsamples;
+};
+
+/* ======================================================================
+   Stat class
+   ====================================================================== */
+
+//! Gather statistics.
+/*!
+  TODO documentation.
+*/
+
+class Stat {
+public:
+	//! Metric subtype (cumulative, time-averaged, averaged).
+	enum SubType { RATE = 0, CONTINUOUS, DISCRETE, TRACE, COUNTER, UNKNOWN };
+
+	//! Metric type, scalar or distribution.
+	enum MetricType { SCALAR, DISTRIBUTION };
+
+	//! Create an empty Stat object.
+	/*!
+	  Data structure are allocated using create_arrays() and initialized using
+	  reinitialize_arrays().
+	  */
+   Stat ();
+
+protected:
+
+	//! Only (static) member. It enforces the allocation of only one Stat object.
+	static Stat stat;
+
+   /*
+    *   PUBLIC METHODS
+    */
+public:
+	//! Deallocate data structures that were allocated using create_arrays().
+   // ~Stat ();
+
+	//! Tcl command interface.
+	static int command (int argc, const char*const* argv);
+
+        //! Reset statistics.
+        static void reset ();
+	
+	//! Start/stop collecting samples.
+	static void active (bool a) { collect = a; }
+	//! Return active flag.
+	static bool active () { return collect; }
+
+	//! Return true if the output file has been correctly opened.
+	static bool initialized () { return (fileout == 0) ? false : true; }
+	//! Open the output file. Return true if successful.
+	static bool initialize (const char* filename);
+
+	//! Insert a new sample.
+	static void put (const char* metric, int ID, double x);
+
+        //! Get the current value of a metric
+        static double get (const char* metric, const int ID);
+
+        //! Add a post processing metric
+        static void addPostProcessMetric(TFunctor* functor);
+
+        //! \todo To be commented
+        static void computeAggregateStatistics();
+
+	//! Print out the collected statistics.
+	static void print ();
+
+	//! Return a reference to the current run duration.
+	static double& runDuration () { return duration; }
+
+	//! Return a reference to the last time that collection was enabled.
+	static double& lastEnabled () { return enabled; }
+
+public:
+	//! Metric descriptor.
+	struct meas_descriptor {
+		//! Last sampling time. Only meaningful with TIME metrics.
+		double lastTime;
+		//! Sum of the sampling times. Only meaningful with TIME metrics.
+		double sumTimes;
+		//! Distribution object.
+		SamplesDist* distribution;
+		//! Average object.
+		SamplesAverage* average;
+
+		//! Create an empty averaged metric descriptor.
+		meas_descriptor () :
+			lastTime (-1.0), sumTimes (0), distribution (0), average (0) { }
+		//! Return true only if initialized, false otherwise.
+		bool initialized () { return ( distribution || average ) ? true : false; }
+		//! Delete the metric descriptor.
+		~meas_descriptor () {
+			if ( distribution ) delete distribution;
+			if ( average ) delete average;
+		}
+	};
+
+	typedef std::map<int, meas_descriptor> MeasMap;
+	typedef std::map<int, FILE*> FileMap;
+
+	//! Metric descriptor.
+	struct stat_desc {
+		//! Metric type, scalar or distribution.
+		MetricType type;
+		//! Metric subtype, only meaningful for averaged metrics.
+		SubType subtype;
+
+		//! Lower bound for distribution metrics.
+		double lower;
+		//! Upper bound for distribution metrics.
+		double upper;
+		//! Number of bins for distribution metrics.
+		int nbins;
+
+		//! Map of metric descriptors.
+		MeasMap metrics;
+
+		//! Map of output trace file descriptors. For trace measures.
+		FileMap trace;
+
+		//! Create an empty metric descriptor.
+		stat_desc () : type (SCALAR), subtype (UNKNOWN),
+							lower (0.0), upper (0.0), nbins (0) { }
+
+	private:
+		// stat_desc (const stat_desc&);
+		stat_desc& operator= (const stat_desc&);
+	};
+
+
+	// typedef google::dense_hash_map<std::string, stat_desc> DescMap;
+	typedef std::map<std::string, stat_desc> DescMap;
+
+        //! Alias for a list of function pointers
+        typedef std::list< TFunctor* > FunctionList;
+	
+   /*
+    *    DATA STRUCTURE
+    */
+private:
+	//! Array of metric descriptors. This is the main data structure.
+	static DescMap metrics;
+
+        //! List of callback function that will be called before print the
+        //! metrics
+        static FunctionList postProcessingFunctions_;
+
+	//! True if statistics collecting is on.
+	static bool collect;
+
+	//! File descriptor to store statistics.
+	static FILE* fileout;
+
+	//! Current run duration.
+	static double duration;
+
+	//! Last time that statistics collection was enabled.
+	static double enabled;
+};
+
+#endif // ns_stat_h 
diff --git a/ns-2.35/common/t_functor.h b/ns-2.35/common/t_functor.h
new file mode 100644
index 0000000..bcac123
--- /dev/null
+++ b/ns-2.35/common/t_functor.h
@@ -0,0 +1,89 @@
+/**
+   project: measure
+   filename: tfunctor.h
+   author: A.Bacioccola <a.bacioccola@iet.unipi.it>
+   year: 2007
+   affiliation:
+      Dipartimento di Ingegneria dell'Informazione
+      University of Pisa, Italy
+   description:
+      class to manage function pointer
+ */
+
+#ifndef ns_tfunctor_h
+#define ns_tfunctor_h
+
+//! abstract base class
+class TFunctor {
+        public:
+        //! call using operator
+        /** two possible functions to call member function. virtual cause 
+         * derived classes will use a pointer to an object and a pointer to a 
+         * member function to make the function call
+         */
+        virtual void operator()(void) = 0;
+
+        //! call using function
+        virtual void call(void) = 0;
+
+        //! Virtual denstructor
+        virtual ~TFunctor() { /* Do Nothing*/ }
+};
+
+
+//! derived template class
+template <typename T>
+class TSpecificFunctor : public TFunctor {
+        public:
+                //! constructor - takes pointer to an object and pointer to a 
+                //! member and stores
+                /** @param [in] _pt2Object Pointer to the class
+                 *  @param [in] _fpt Pointer to a class function member
+                 */
+                TSpecificFunctor(T* _pt2Object, 
+                                 void(T::*_fpt)(void));
+
+                //! Denstructor
+                virtual ~TSpecificFunctor() { /* Do Nothing */ }
+
+                //! override operator "()"
+                /** execute member function
+                 */
+                virtual void operator()(void);
+
+                //! override function "Call"
+                /** execute member function
+                 */
+                virtual void call(void);
+
+        private:
+                //! pointer to member function
+                void (T::*fpt)(void);
+
+                //! pointer to object
+                T* pt2Object;
+};
+
+template <typename T>
+TSpecificFunctor<T>::TSpecificFunctor( T* _pt2Object,
+                                       void(T::*_fpt)(void) )
+{
+        pt2Object = _pt2Object;
+        fpt=_fpt;
+}
+
+template <typename T>
+void
+TSpecificFunctor<T>::operator()(void)
+{
+        (*pt2Object.*fpt)();
+}
+
+template <typename T>
+void
+TSpecificFunctor<T>::call(void)
+{ 
+        (*pt2Object.*fpt)();
+}
+
+#endif
\ No newline at end of file
diff --git a/ns-2.35/common/t_timers.cc b/ns-2.35/common/t_timers.cc
new file mode 100644
index 0000000..5584aaf
--- /dev/null
+++ b/ns-2.35/common/t_timers.cc
@@ -0,0 +1,16 @@
+/**
+*  project: VoIP module for ns2
+*  filename: t_timers.cc
+*      author: C. Cicconetti <c.cicconetti@iet.unipi.it>
+*               A. Erta <alessandro.erta@imtlucca.it>
+*               A. Bacioccola <a.bacioccola@iet.unipi.it>
+*       year: 2007
+*  affiliation:
+*       Dipartimento di Ingegneria dell'Informazione
+*               University of Pisa, Italy
+*  description:
+*      Template timers (T_Timers)
+*/
+
+#include <t_timers.h>
+ 
diff --git a/ns-2.35/common/t_timers.h b/ns-2.35/common/t_timers.h
new file mode 100644
index 0000000..493ba64
--- /dev/null
+++ b/ns-2.35/common/t_timers.h
@@ -0,0 +1,328 @@
+/**
+ *  project: VoIP module for ns2
+ *  filename: generic_timers.h
+ *       author: C. Cicconetti <c.cicconetti@iet.unipi.it>
+ *               A. Erta <alessandro.erta@imtlucca.it>
+ *               A. Bacioccola <a.bacioccola@iet.unipi.it>
+ *  year: 2007
+ *  affiliation:
+ *       Dipartimento di Ingegneria dell'Informazione
+ *       University of Pisa, Italy
+ *  description:
+ *       Template timers (T_Timers)
+ */
+
+#ifndef __NS2_T_TIMERS_H
+#define __NS2_T_TIMERS_H
+
+#include <scheduler.h>
+#include <object.h> // NOW definition
+
+#include <queue>
+#include <map>
+#include <list>
+#include <iostream>
+
+//! Generic timer interface.
+template<typename T>
+class TTimer : public Handler {
+public:
+        //! Build an idle timer.
+        TTimer (T* obj) { obj_ = obj;
+                                busy_ = false;
+                                start_ = 0;
+                                expire_ = 0; }
+
+        //! Do nothing.
+        virtual ~TTimer () { }
+
+        //! Handle the event.
+        virtual void handle (Event* e);
+
+        //! Start the timer. The timer is now busy.
+        /**
+         * If the timer has been already started, then probably there is
+         * a programming error. Thus, we abort execution immediately.
+         */
+        virtual void start (double t);
+
+        //! Stop the timer, if busy. The timer is now idle.
+        virtual void stop ();
+
+        //! Return true if the timer is busy.
+        virtual bool busy () { return busy_; }
+
+        //! Return true if the timer is idle.
+        virtual bool idle () { return ! busy_; }
+
+        //! Return the elapsed time from timer start.
+        virtual double elapsed () { return NOW - start_; }
+
+        //! Return the remaining time before expiration.
+        virtual double remaining () { return expire_ - NOW; }
+
+protected:
+        //! Object for handling the event.
+        T* obj_;
+
+        //! Used for scheduling an event into the ns2 event scheduler
+        Event intr_;
+
+        //! True if the the timer has been already started.
+        bool busy_;
+
+        //! Last time the timer was started.
+        double start_;
+
+        //! Expire time.
+        double expire_;
+};
+
+template<typename T>
+void
+TTimer<T>::start (double t)
+{
+        if ( busy_ ) abort();
+        Scheduler::instance().schedule (this, &intr_, t);
+        busy_ = true;
+        start_ = NOW;
+        expire_ = NOW + t;
+}
+
+template<typename T>
+void
+TTimer<T>::stop ()
+{
+        if ( busy_ ) Scheduler::instance().cancel (&intr_);
+        busy_ = false;
+}
+
+template<typename T>
+void
+TTimer<T>::handle (Event* e)
+{
+        busy_ = false;
+        obj_->handle ();
+}
+
+//! Generic multi-timer interface.
+/*!
+  A multi-timer is a timer that handles many events. Events are just added
+  to the multi-timer, which will dispatch them all when needed. To
+  distinguish between different events, if needed, the handler is called
+  with an argument of a specified user data type.
+  */
+template<typename T, typename R>
+class TMultiTimer : public Handler {
+public:
+	//! Build an idle multi-timer.
+	TMultiTimer (T* obj) { obj_ = obj; busy_ = false; }
+	//! Do nothing.
+	virtual ~TMultiTimer () { }
+	//! Handle the event.
+	virtual void handle (Event* e);
+	//! Add an event to the multi-timer, with a specified parameter.
+	virtual void add (double t, R arg);
+	//! Return true if there is at least one scheduled event.
+	virtual bool busy () { return busy_; }
+	//! Return true if there are no scheduled events.
+	virtual bool idle () { return ! busy_; }
+protected:
+	//! Object for handling the event.
+	T* obj_;
+	//! Used for scheduling an event into the ns2 event scheduler
+	Event intr_;
+	//! True if there is at least one scheduled event.
+	bool busy_;
+	//! Priority queue to store the event list.
+   /*!
+     Note that finish times are stored as negative values, so as
+     to have the earlierst event scheduled first.
+     */
+	std::priority_queue< std::pair<double,R> > prio_;
+};
+
+template<typename T, typename R>
+void
+TMultiTimer<T, R>::add (double t, R arg)
+{
+	double remaining = -1.0;
+
+	// retrieve the ns2 event expire time
+	if ( busy_ ) {
+		std::pair<double, R> earliest = prio_.top();
+		remaining = - ( NOW + earliest.first );
+	}
+
+	// add the event to the priority queue, along with its argument
+	prio_.push (std::pair<double, R> (-(NOW + t), arg));
+
+	// if this event finishes earlier than the earliest scheduled event, if any
+	// then we have to reschedule the ns2 event
+	if ( ! busy_ || t < remaining ) {
+		if ( busy_ ) Scheduler::instance().cancel (&intr_);
+		Scheduler::instance().schedule (this, &intr_, t);
+	}
+
+	busy_ = true;
+}
+
+template<typename T, typename R>
+void
+TMultiTimer<T, R>::handle (Event* e)
+{
+	// retrieve the earliest event to dispatch
+	std::pair<double, R> first = prio_.top();
+
+	// remove it
+	prio_.pop ();
+
+	// reschedule the timer to manage the earliest event, if any
+	if ( prio_.empty() )
+		busy_ = false;
+	else {
+		std::pair<double, R> second = prio_.top();
+		Scheduler::instance().schedule (this, &intr_, - ( NOW + second.first ) );
+	}
+
+	// finally, handle the event
+	obj_->handle (first.second);
+}
+
+//! Multi-timer enhanced.T
+/*!
+    Same as the multitime but events can be removed
+ */
+
+template<typename T, typename R>
+class TMultiTimerPlus : public Handler {
+public:
+        //! Build an idle multi-timer.
+        TMultiTimerPlus (T* obj) { obj_ = obj; busy_ = false; }
+        //! Do nothing.
+        virtual ~TMultiTimerPlus () { }
+        //! Handle the event.
+        virtual void handle (Event* e);
+        //! Add an event to the multi-timer, with a specified parameter.
+        virtual void add (double t, R arg);
+        //! Remove an event. Note that event id are assumed to be unique
+        virtual void remove ( R arg );
+        //! Return true if there is at least one scheduled event.
+        virtual bool busy () { return busy_; }
+        //! Return true if the event id exists
+        virtual bool busy (R arg);
+        //! Return true if there are no scheduled events.
+        virtual bool idle () { return ! busy_; }
+protected:
+        //! Object for handling the event.
+        T* obj_;
+        //! Used for scheduling an event into the ns2 event scheduler
+        Event intr_;
+        //! True if there is at least one scheduled event.
+        bool busy_;
+        //! The event list.
+        std::list< std::pair<double,R> > ordList_;
+        //! The removable list. Each event id matches with a pair.
+        std::map< R, std::pair<double, R> > removeMap_;
+};
+
+template<typename T, typename R>
+void
+TMultiTimerPlus<T, R>::add (double t, R arg)
+{
+        double remaining = 1.0;
+
+        // retrieve the ns2 event expire time
+        if ( busy_ ) {
+                std::pair<double, R> earliest = ordList_.front();
+                remaining = ( earliest.first -  NOW );
+        }
+
+        // add the event to the priority queue, along with its argument
+        ordList_.push_back (std::pair<double, R> ((NOW + t), arg));
+
+        // the list should be ordered each time :-(
+        ordList_.sort();
+
+        // add the information to the removeMap_
+        // If the element already exists abort
+        if ( removeMap_.find(arg) != removeMap_.end() ) {
+                fprintf(stderr, "MultiTimerPlus - Error\n");
+                abort();
+        }
+        removeMap_[ arg ] = std::pair<double, R> ((NOW + t), arg);
+
+        // if this event finishes earlier than the earliest scheduled event, if any
+        // then we have to reschedule the ns2 event
+        if ( ! busy_ || t < remaining ) {
+                if ( busy_ ) Scheduler::instance().cancel (&intr_);
+                Scheduler::instance().schedule (this, &intr_, t);
+        }
+
+        busy_ = true;
+}
+template<typename T, typename R>
+bool
+TMultiTimerPlus<T, R>::busy (R arg)
+{
+        if ( removeMap_.find(arg) != removeMap_.end() ) {
+                return true;
+        }
+        else {
+                return false;
+        }
+}
+
+template<typename T, typename R>
+void
+TMultiTimerPlus<T, R>::handle (Event* e)
+{
+        // retrieve the earliest event to dispatch
+        std::pair<double, R> first = ordList_.front();
+
+        // remove it
+        ordList_.pop_front ();
+
+        // remove the information also in the removeMap_
+        removeMap_.erase ( first.second );
+
+        // reschedule the timer to manage the earliest event, if any
+        if ( ordList_.empty() )
+                busy_ = false;
+        else {
+                std::pair<double, R> second = ordList_.front();
+                Scheduler::instance().schedule (this, &intr_,( second.first - NOW ) );
+        }
+
+        // finally, handle the event
+        obj_->handle (first.second);
+}
+
+template<typename T, typename R>
+void
+TMultiTimerPlus<T, R>::remove( R arg )
+{
+        typename std::map< R, std::pair<double, R> >::iterator it = removeMap_.find( arg );
+
+        if ( it == removeMap_.end() ) abort (); // not possible
+
+        // check if the event is the earliest to be scheduled
+        if ( it->second == ordList_.front() ) {
+                // remove it
+                ordList_.pop_front ();
+                Scheduler::instance().cancel (&intr_);
+                // schedule next event
+                if ( ordList_.empty() )
+                        busy_ = false;
+                else {
+                        std::pair<double, R> second = ordList_.front();
+                        Scheduler::instance().schedule (this, &intr_, ( second.first - NOW ) );
+                }
+        } else ordList_.remove ( it->second );
+
+        // remove from the remove list
+        removeMap_.erase ( it );
+
+}
+
+#endif // __NS2_T_TIMERS_H 
diff --git a/ns-2.35/common/tfunctor.cc b/ns-2.35/common/tfunctor.cc
new file mode 100644
index 0000000..cb7a4da
--- /dev/null
+++ b/ns-2.35/common/tfunctor.cc
@@ -0,0 +1,13 @@
+/**
+   project: measure
+   filename: tfunctor.cc
+   author: A.Bacioccola <a.bacioccola@iet.unipi.it>
+   year: 2007
+   affiliation:
+      Dipartimento di Ingegneria dell'Informazione
+      University of Pisa, Italy
+   description:
+      class to manage function pointer
+ */
+
+#include <tfunctor.h>
\ No newline at end of file
diff --git a/ns-2.35/common/tfunctor.h b/ns-2.35/common/tfunctor.h
new file mode 100644
index 0000000..bcac123
--- /dev/null
+++ b/ns-2.35/common/tfunctor.h
@@ -0,0 +1,89 @@
+/**
+   project: measure
+   filename: tfunctor.h
+   author: A.Bacioccola <a.bacioccola@iet.unipi.it>
+   year: 2007
+   affiliation:
+      Dipartimento di Ingegneria dell'Informazione
+      University of Pisa, Italy
+   description:
+      class to manage function pointer
+ */
+
+#ifndef ns_tfunctor_h
+#define ns_tfunctor_h
+
+//! abstract base class
+class TFunctor {
+        public:
+        //! call using operator
+        /** two possible functions to call member function. virtual cause 
+         * derived classes will use a pointer to an object and a pointer to a 
+         * member function to make the function call
+         */
+        virtual void operator()(void) = 0;
+
+        //! call using function
+        virtual void call(void) = 0;
+
+        //! Virtual denstructor
+        virtual ~TFunctor() { /* Do Nothing*/ }
+};
+
+
+//! derived template class
+template <typename T>
+class TSpecificFunctor : public TFunctor {
+        public:
+                //! constructor - takes pointer to an object and pointer to a 
+                //! member and stores
+                /** @param [in] _pt2Object Pointer to the class
+                 *  @param [in] _fpt Pointer to a class function member
+                 */
+                TSpecificFunctor(T* _pt2Object, 
+                                 void(T::*_fpt)(void));
+
+                //! Denstructor
+                virtual ~TSpecificFunctor() { /* Do Nothing */ }
+
+                //! override operator "()"
+                /** execute member function
+                 */
+                virtual void operator()(void);
+
+                //! override function "Call"
+                /** execute member function
+                 */
+                virtual void call(void);
+
+        private:
+                //! pointer to member function
+                void (T::*fpt)(void);
+
+                //! pointer to object
+                T* pt2Object;
+};
+
+template <typename T>
+TSpecificFunctor<T>::TSpecificFunctor( T* _pt2Object,
+                                       void(T::*_fpt)(void) )
+{
+        pt2Object = _pt2Object;
+        fpt=_fpt;
+}
+
+template <typename T>
+void
+TSpecificFunctor<T>::operator()(void)
+{
+        (*pt2Object.*fpt)();
+}
+
+template <typename T>
+void
+TSpecificFunctor<T>::call(void)
+{ 
+        (*pt2Object.*fpt)();
+}
+
+#endif
\ No newline at end of file
diff --git a/ns-2.35/config.log b/ns-2.35/config.log
new file mode 100644
index 0000000..fed81c7
--- /dev/null
+++ b/ns-2.35/config.log
@@ -0,0 +1,911 @@
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by configure, which was
+generated by GNU Autoconf 2.68.  Invocation command line was
+
+  $ ./configure 
+
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = snf-11211
+uname -m = x86_64
+uname -r = 2.6.32-5-amd64
+uname -s = Linux
+uname -v = #1 SMP Sun Sep 23 10:07:46 UTC 2012
+
+/usr/bin/uname -p = unknown
+/bin/uname -X     = unknown
+
+/bin/arch              = unknown
+/usr/bin/arch -k       = unknown
+/usr/convex/getsysinfo = unknown
+/usr/bin/hostinfo      = unknown
+/bin/machine           = unknown
+/usr/bin/oslevel       = unknown
+/bin/universe          = unknown
+
+PATH: /usr/local/bin
+PATH: /usr/bin
+PATH: /bin
+PATH: /usr/local/games
+PATH: /usr/games
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+configure:2498: checking for gcc
+configure:2514: found /usr/bin/gcc
+configure:2525: result: gcc
+configure:2754: checking for C compiler version
+configure:2763: gcc --version >&5
+gcc (Debian 4.4.5-8) 4.4.5
+Copyright (C) 2010 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:2774: $? = 0
+configure:2763: gcc -v >&5
+Using built-in specs.
+Target: x86_64-linux-gnu
+Configured with: ../src/configure -v --with-pkgversion='Debian 4.4.5-8' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.4 --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-objc-gc --with-arch-32=i586 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
+Thread model: posix
+gcc version 4.4.5 (Debian 4.4.5-8) 
+configure:2774: $? = 0
+configure:2763: gcc -V >&5
+gcc: '-V' option must have argument
+configure:2774: $? = 1
+configure:2763: gcc -qversion >&5
+gcc: unrecognized option '-qversion'
+gcc: no input files
+configure:2774: $? = 1
+configure:2794: checking whether the C compiler works
+configure:2816: gcc    conftest.c  >&5
+configure:2820: $? = 0
+configure:2868: result: yes
+configure:2871: checking for C compiler default output file name
+configure:2873: result: a.out
+configure:2879: checking for suffix of executables
+configure:2886: gcc -o conftest    conftest.c  >&5
+configure:2890: $? = 0
+configure:2912: result: 
+configure:2934: checking whether we are cross compiling
+configure:2942: gcc -o conftest    conftest.c  >&5
+configure:2946: $? = 0
+configure:2953: ./conftest
+configure:2957: $? = 0
+configure:2972: result: no
+configure:2977: checking for suffix of object files
+configure:2999: gcc -c   conftest.c >&5
+configure:3003: $? = 0
+configure:3024: result: o
+configure:3028: checking whether we are using the GNU C compiler
+configure:3047: gcc -c   conftest.c >&5
+configure:3047: $? = 0
+configure:3056: result: yes
+configure:3065: checking whether gcc accepts -g
+configure:3085: gcc -c -g  conftest.c >&5
+configure:3085: $? = 0
+configure:3126: result: yes
+configure:3143: checking for gcc option to accept ISO C89
+configure:3207: gcc  -c -g -O2  conftest.c >&5
+configure:3207: $? = 0
+configure:3220: result: none needed
+configure:3246: checking how to run the C preprocessor
+configure:3277: gcc -E  conftest.c
+configure:3277: $? = 0
+configure:3291: gcc -E  conftest.c
+conftest.c:9:28: error: ac_nonexistent.h: No such file or directory
+configure:3291: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:3316: result: gcc -E
+configure:3336: gcc -E  conftest.c
+configure:3336: $? = 0
+configure:3350: gcc -E  conftest.c
+conftest.c:9:28: error: ac_nonexistent.h: No such file or directory
+configure:3350: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:3379: checking for grep that handles long lines and -e
+configure:3437: result: /bin/grep
+configure:3442: checking for egrep
+configure:3504: result: /bin/grep -E
+configure:3509: checking for ANSI C header files
+configure:3529: gcc -c -g -O2  conftest.c >&5
+configure:3529: $? = 0
+configure:3602: gcc -o conftest -g -O2   conftest.c  >&5
+configure:3602: $? = 0
+configure:3602: ./conftest
+configure:3602: $? = 0
+configure:3613: result: yes
+configure:3626: checking for sys/types.h
+configure:3626: gcc -c -g -O2  conftest.c >&5
+configure:3626: $? = 0
+configure:3626: result: yes
+configure:3626: checking for sys/stat.h
+configure:3626: gcc -c -g -O2  conftest.c >&5
+configure:3626: $? = 0
+configure:3626: result: yes
+configure:3626: checking for stdlib.h
+configure:3626: gcc -c -g -O2  conftest.c >&5
+configure:3626: $? = 0
+configure:3626: result: yes
+configure:3626: checking for string.h
+configure:3626: gcc -c -g -O2  conftest.c >&5
+configure:3626: $? = 0
+configure:3626: result: yes
+configure:3626: checking for memory.h
+configure:3626: gcc -c -g -O2  conftest.c >&5
+configure:3626: $? = 0
+configure:3626: result: yes
+configure:3626: checking for strings.h
+configure:3626: gcc -c -g -O2  conftest.c >&5
+configure:3626: $? = 0
+configure:3626: result: yes
+configure:3626: checking for inttypes.h
+configure:3626: gcc -c -g -O2  conftest.c >&5
+configure:3626: $? = 0
+configure:3626: result: yes
+configure:3626: checking for stdint.h
+configure:3626: gcc -c -g -O2  conftest.c >&5
+configure:3626: $? = 0
+configure:3626: result: yes
+configure:3626: checking for unistd.h
+configure:3626: gcc -c -g -O2  conftest.c >&5
+configure:3626: $? = 0
+configure:3626: result: yes
+configure:3639: checking minix/config.h usability
+configure:3639: gcc -c -g -O2  conftest.c >&5
+conftest.c:52:26: error: minix/config.h: No such file or directory
+configure:3639: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| /* end confdefs.h.  */
+| #include <stdio.h>
+| #ifdef HAVE_SYS_TYPES_H
+| # include <sys/types.h>
+| #endif
+| #ifdef HAVE_SYS_STAT_H
+| # include <sys/stat.h>
+| #endif
+| #ifdef STDC_HEADERS
+| # include <stdlib.h>
+| # include <stddef.h>
+| #else
+| # ifdef HAVE_STDLIB_H
+| #  include <stdlib.h>
+| # endif
+| #endif
+| #ifdef HAVE_STRING_H
+| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+| #  include <memory.h>
+| # endif
+| # include <string.h>
+| #endif
+| #ifdef HAVE_STRINGS_H
+| # include <strings.h>
+| #endif
+| #ifdef HAVE_INTTYPES_H
+| # include <inttypes.h>
+| #endif
+| #ifdef HAVE_STDINT_H
+| # include <stdint.h>
+| #endif
+| #ifdef HAVE_UNISTD_H
+| # include <unistd.h>
+| #endif
+| #include <minix/config.h>
+configure:3639: result: no
+configure:3639: checking minix/config.h presence
+configure:3639: gcc -E  conftest.c
+conftest.c:19:26: error: minix/config.h: No such file or directory
+configure:3639: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| /* end confdefs.h.  */
+| #include <minix/config.h>
+configure:3639: result: no
+configure:3639: checking for minix/config.h
+configure:3639: result: no
+configure:3660: checking whether it is safe to define __EXTENSIONS__
+configure:3678: gcc -c -g -O2  conftest.c >&5
+configure:3678: $? = 0
+configure:3685: result: yes
+configure:3811: checking build system type
+configure:3825: result: x86_64-unknown-linux-gnu
+configure:3845: checking host system type
+configure:3858: result: x86_64-unknown-linux-gnu
+configure:3878: checking target system type
+configure:3891: result: x86_64-unknown-linux-gnu
+configure:3967: checking for gcc
+configure:3994: result: gcc
+configure:4223: checking for C compiler version
+configure:4232: gcc --version >&5
+gcc (Debian 4.4.5-8) 4.4.5
+Copyright (C) 2010 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:4243: $? = 0
+configure:4232: gcc -v >&5
+Using built-in specs.
+Target: x86_64-linux-gnu
+Configured with: ../src/configure -v --with-pkgversion='Debian 4.4.5-8' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.4 --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-objc-gc --with-arch-32=i586 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
+Thread model: posix
+gcc version 4.4.5 (Debian 4.4.5-8) 
+configure:4243: $? = 0
+configure:4232: gcc -V >&5
+gcc: '-V' option must have argument
+configure:4243: $? = 1
+configure:4232: gcc -qversion >&5
+gcc: unrecognized option '-qversion'
+gcc: no input files
+configure:4243: $? = 1
+configure:4247: checking whether we are using the GNU C compiler
+configure:4275: result: yes
+configure:4284: checking whether gcc accepts -g
+configure:4345: result: yes
+configure:4362: checking for gcc option to accept ISO C89
+configure:4439: result: none needed
+configure:4517: checking for g++
+configure:4533: found /usr/bin/g++
+configure:4544: result: g++
+configure:4571: checking for C++ compiler version
+configure:4580: g++ --version >&5
+g++ (Debian 4.4.5-8) 4.4.5
+Copyright (C) 2010 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:4591: $? = 0
+configure:4580: g++ -v >&5
+Using built-in specs.
+Target: x86_64-linux-gnu
+Configured with: ../src/configure -v --with-pkgversion='Debian 4.4.5-8' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.4 --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-objc-gc --with-arch-32=i586 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
+Thread model: posix
+gcc version 4.4.5 (Debian 4.4.5-8) 
+configure:4591: $? = 0
+configure:4580: g++ -V >&5
+g++: '-V' option must have argument
+configure:4591: $? = 1
+configure:4580: g++ -qversion >&5
+g++: unrecognized option '-qversion'
+g++: no input files
+configure:4591: $? = 1
+configure:4595: checking whether we are using the GNU C++ compiler
+configure:4614: g++ -c   conftest.cpp >&5
+configure:4614: $? = 0
+configure:4623: result: yes
+configure:4632: checking whether g++ accepts -g
+configure:4652: g++ -c -g  conftest.cpp >&5
+configure:4652: $? = 0
+configure:4693: result: yes
+configure:4716: checking for ANSI C header files
+configure:4820: result: yes
+configure:4830: checking for string.h
+configure:4830: result: yes
+configure:4850: checking for main in -lXbsd
+configure:4869: gcc -o conftest -g -O2   conftest.c -lXbsd   >&5
+/usr/bin/ld: cannot find -lXbsd
+collect2: ld returned 1 exit status
+configure:4869: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define __EXTENSIONS__ 1
+| #define _ALL_SOURCE 1
+| #define _GNU_SOURCE 1
+| #define _POSIX_PTHREAD_SEMANTICS 1
+| #define _TANDEM_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_STRING_H 1
+| /* end confdefs.h.  */
+| 
+| 
+| int
+| main ()
+| {
+| return main ();
+|   ;
+|   return 0;
+| }
+configure:4878: result: no
+configure:4884: checking for socket in -lsocket
+configure:4909: gcc -o conftest -g -O2   conftest.c -lsocket   >&5
+/usr/bin/ld: cannot find -lsocket
+collect2: ld returned 1 exit status
+configure:4909: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define __EXTENSIONS__ 1
+| #define _ALL_SOURCE 1
+| #define _GNU_SOURCE 1
+| #define _POSIX_PTHREAD_SEMANTICS 1
+| #define _TANDEM_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_STRING_H 1
+| /* end confdefs.h.  */
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char socket ();
+| int
+| main ()
+| {
+| return socket ();
+|   ;
+|   return 0;
+| }
+configure:4918: result: no
+configure:4924: checking for gethostbyname in -lnsl
+configure:4949: gcc -o conftest -g -O2   conftest.c -lnsl   >&5
+configure:4949: $? = 0
+configure:4958: result: yes
+configure:4964: checking for dcgettext in -lintl
+configure:4989: gcc -o conftest -g -O2   conftest.c -lintl   >&5
+conftest.c:33: warning: conflicting types for built-in function 'dcgettext'
+/usr/bin/ld: cannot find -lintl
+collect2: ld returned 1 exit status
+configure:4989: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define __EXTENSIONS__ 1
+| #define _ALL_SOURCE 1
+| #define _GNU_SOURCE 1
+| #define _POSIX_PTHREAD_SEMANTICS 1
+| #define _TANDEM_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_STRING_H 1
+| /* end confdefs.h.  */
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char dcgettext ();
+| int
+| main ()
+| {
+| return dcgettext ();
+|   ;
+|   return 0;
+| }
+configure:4998: result: no
+configure:5004: checking for getnodebyname in -ldnet_stub
+configure:5029: gcc -o conftest -g -O2   conftest.c -ldnet_stub   >&5
+/usr/bin/ld: cannot find -ldnet_stub
+collect2: ld returned 1 exit status
+configure:5029: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define __EXTENSIONS__ 1
+| #define _ALL_SOURCE 1
+| #define _GNU_SOURCE 1
+| #define _POSIX_PTHREAD_SEMANTICS 1
+| #define _TANDEM_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_STRING_H 1
+| /* end confdefs.h.  */
+| 
+| /* Override any GCC internal prototype to avoid an error.
+|    Use char because int might match the return type of a GCC
+|    builtin and then its argument prototype would still apply.  */
+| #ifdef __cplusplus
+| extern "C"
+| #endif
+| char getnodebyname ();
+| int
+| main ()
+| {
+| return getnodebyname ();
+|   ;
+|   return 0;
+| }
+configure:5038: result: no
+configure:5084: checking that g++ can handle -O2
+configure:5105: gcc -c -g -O2  conftest.c >&5
+conftest.c: In function 'main':
+conftest.c:32: error: 'error' undeclared (first use in this function)
+conftest.c:32: error: (Each undeclared identifier is reported only once
+conftest.c:32: error: for each function it appears in.)
+conftest.c:36: error: expected ';' before 'int'
+configure:5105: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define __EXTENSIONS__ 1
+| #define _ALL_SOURCE 1
+| #define _GNU_SOURCE 1
+| #define _POSIX_PTHREAD_SEMANTICS 1
+| #define _TANDEM_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_STRING_H 1
+| /* end confdefs.h.  */
+| 
+| int
+| main ()
+| {
+| #if __GNUC__ < 2  || __GNUC_MINOR__ < 8
+| 		/* gcc */
+| 		error
+| 		#endif
+| 		#if __GNUC_MINOR__ < 92
+| 		/* egcs */
+| 		int error;
+| 		#endif
+| 
+|   ;
+|   return 0;
+| }
+configure:5111: result: no
+configure:5226: checking if C++ libraries work without any namespace
+configure:5242: g++ -c -g -O2  conftest.cpp >&5
+conftest.cpp: In function 'int main()':
+conftest.cpp:31: error: 'cout' was not declared in this scope
+configure:5242: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define __EXTENSIONS__ 1
+| #define _ALL_SOURCE 1
+| #define _GNU_SOURCE 1
+| #define _POSIX_PTHREAD_SEMANTICS 1
+| #define _TANDEM_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_STRING_H 1
+| /* end confdefs.h.  */
+| #include <iostream>
+| 
+| int
+| main ()
+| {
+| cout.fail();
+| 
+|   ;
+|   return 0;
+| }
+configure:5248: result: no
+configure:5256: checking if C++ libraries work with namespace std
+configure:5272: g++ -c -g -O2  conftest.cpp >&5
+configure:5272: $? = 0
+configure:5273: result: yes
+configure:5287: checking if STL works without any namespace
+configure:5302: g++ -c -g -O2  conftest.cpp >&5
+conftest.cpp: In function 'int main()':
+conftest.cpp:31: error: 'list' was not declared in this scope
+conftest.cpp:31: error: expected primary-expression before 'int'
+conftest.cpp:31: error: expected ';' before 'int'
+configure:5302: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define PACKAGE_URL ""
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define __EXTENSIONS__ 1
+| #define _ALL_SOURCE 1
+| #define _GNU_SOURCE 1
+| #define _POSIX_PTHREAD_SEMANTICS 1
+| #define _TANDEM_SOURCE 1
+| #define STDC_HEADERS 1
+| #define HAVE_STRING_H 1
+| /* end confdefs.h.  */
+| #include <list>
+| 
+| int
+| main ()
+| {
+| list<int> test;
+| 
+|   ;
+|   return 0;
+| }
+configure:5308: result: no
+configure:5316: checking if STL works with namespace std
+configure:5332: g++ -c -g -O2  conftest.cpp >&5
+configure:5332: $? = 0
+configure:5333: result: yes
+configure:5383: checking should use STL
+configure:5407: result: yes
+configure:5653: checking for tcl.h
+configure:5704: result: -I../include
+configure:5710: checking for tclInt.h
+configure:5761: result: -I../include
+configure:5767: checking for libtcl8.4
+configure:5810: result: no
+configure:5835: checking for init.tcl
+configure:5872: result: ../lib/tcl8.5
+configure:5890: checking for http.tcl
+configure:5927: result: ../lib/tcl8.5/http1.0
+configure:5932: checking Tcl http.tcl library
+configure:5936: result: yes
+configure:5957: checking for tclsh8.4.19
+configure:5990: result: no
+configure:5957: checking for tclsh8.4
+configure:5975: found /usr/bin/tclsh8.4
+configure:5987: result: /usr/bin/tclsh8.4
+configure:6017: error: Installation of tcl seems incomplete or can't be found automatically.
+Please correct the problem by telling configure where tcl is
+using the argument --with-tcl=/path/to/package
+(perhaps after installing it),
+or the package is not required, disable it with --with-tcl=no.
+
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+
+ac_cv_build=x86_64-unknown-linux-gnu
+ac_cv_c_compiler_gnu=yes
+ac_cv_cxx_compiler_gnu=yes
+ac_cv_env_CCC_set=
+ac_cv_env_CCC_value=
+ac_cv_env_CC_set=
+ac_cv_env_CC_value=
+ac_cv_env_CFLAGS_set=
+ac_cv_env_CFLAGS_value=
+ac_cv_env_CPPFLAGS_set=
+ac_cv_env_CPPFLAGS_value=
+ac_cv_env_CPP_set=
+ac_cv_env_CPP_value=
+ac_cv_env_CXXFLAGS_set=
+ac_cv_env_CXXFLAGS_value=
+ac_cv_env_CXX_set=
+ac_cv_env_CXX_value=
+ac_cv_env_LDFLAGS_set=
+ac_cv_env_LDFLAGS_value=
+ac_cv_env_LIBS_set=
+ac_cv_env_LIBS_value=
+ac_cv_env_build_alias_set=
+ac_cv_env_build_alias_value=
+ac_cv_env_host_alias_set=
+ac_cv_env_host_alias_value=
+ac_cv_env_target_alias_set=
+ac_cv_env_target_alias_value=
+ac_cv_header_inttypes_h=yes
+ac_cv_header_memory_h=yes
+ac_cv_header_minix_config_h=no
+ac_cv_header_stdc=yes
+ac_cv_header_stdint_h=yes
+ac_cv_header_stdlib_h=yes
+ac_cv_header_string_h=yes
+ac_cv_header_strings_h=yes
+ac_cv_header_sys_stat_h=yes
+ac_cv_header_sys_types_h=yes
+ac_cv_header_unistd_h=yes
+ac_cv_host=x86_64-unknown-linux-gnu
+ac_cv_lib_Xbsd_main=no
+ac_cv_lib_dnet_stub_getnodebyname=no
+ac_cv_lib_intl_dcgettext=no
+ac_cv_lib_nsl_gethostbyname=yes
+ac_cv_lib_socket_socket=no
+ac_cv_objext=o
+ac_cv_path_EGREP='/bin/grep -E'
+ac_cv_path_GREP=/bin/grep
+ac_cv_path_V_TCLSH=/usr/bin/tclsh8.4
+ac_cv_prog_CPP='gcc -E'
+ac_cv_prog_ac_ct_CC=gcc
+ac_cv_prog_ac_ct_CXX=g++
+ac_cv_prog_cc_c89=
+ac_cv_prog_cc_g=yes
+ac_cv_prog_cxx_g=yes
+ac_cv_safe_to_define___extensions__=yes
+ac_cv_target=x86_64-unknown-linux-gnu
+
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+
+CC='gcc'
+CFLAGS='-g -O2'
+CPP='gcc -E'
+CPPFLAGS=''
+CPP_NAMESPACE='std'
+CXX='g++'
+CXXFLAGS='-g -O2'
+DEFS=''
+DL_LD_FLAGS=''
+DL_LD_SEARCH_FLAGS=''
+DL_LIBS=''
+ECHO_C=''
+ECHO_N='-n'
+ECHO_T=''
+EGREP='/bin/grep -E'
+EXEEXT=''
+GREP='/bin/grep'
+INSTALL_DATA=''
+INSTALL_PROGRAM=''
+INSTALL_SCRIPT=''
+LDFLAGS=''
+LIBOBJS=''
+LIBS=''
+LTLIBOBJS=''
+NSLIB=''
+OBJEXT='o'
+PACKAGE_BUGREPORT=''
+PACKAGE_NAME=''
+PACKAGE_STRING=''
+PACKAGE_TARNAME=''
+PACKAGE_URL=''
+PACKAGE_VERSION=''
+PATH_SEPARATOR=':'
+PERL=''
+PKG_SHLIB_CFLAGS=''
+SHELL='/bin/bash'
+SHLIB_CFLAGS=''
+SHLIB_LD=''
+SHLIB_LD_LIBS=''
+SHLIB_SUFFIX=''
+V_ALL=''
+V_AR='ar cr'
+V_BROKEN_OBJ='strtol.o strtoul.o'
+V_CCOPT=' -Wall -Wno-write-strings'
+V_DEFINE=' -DNDEBUG'
+V_DEFINES='-DHAVE_TCLINT_H -DHAVE_TCL_H '
+V_IMPORT_LIBS=''
+V_INCLUDE=''
+V_INCLUDES='-I../include -I../include '
+V_INCLUDE_X11=''
+V_LIB=' -lnsl'
+V_LIBRARY_TCL='../lib/tcl8.5'
+V_LIBRARY_TK=''
+V_LIBS=''
+V_LIB_OTCL=''
+V_LIB_TCL=''
+V_LIB_TCLCL=''
+V_LIB_TK=''
+V_LIB_X11=''
+V_LSSCRIPT=''
+V_NS_TCL_LIB_STL='$(NS_TCL_LIB_STL)'
+V_OBJ=''
+V_OBJ_CRYPT=''
+V_RANLIB='ranlib'
+V_SHELL=''
+V_SIGRET='void'
+V_STATIC=''
+V_STLOBJ='$(OBJ_STL)'
+V_TARCMD='tar cfh'
+V_TAR_EXTRA=''
+V_TAR_TARGET=''
+V_TCL2CPP=''
+V_TCLSH='/usr/bin/tclsh8.4'
+V_TCL_LIBRARY_FILES='$(TCL_BASE_LIBRARY_FILES) ../lib/tcl8.5/http1.0/http.tcl'
+V_TKDOSNAMES=''
+ac_ct_CC='gcc'
+ac_ct_CXX='g++'
+bindir='${exec_prefix}/bin'
+build='x86_64-unknown-linux-gnu'
+build_alias=''
+build_cpu='x86_64'
+build_nse=''
+build_os='linux-gnu'
+build_vendor='unknown'
+datadir='${datarootdir}'
+datarootdir='${prefix}/share'
+docdir='${datarootdir}/doc/${PACKAGE}'
+dvidir='${docdir}'
+exec_prefix='NONE'
+host='x86_64-unknown-linux-gnu'
+host_alias=''
+host_cpu='x86_64'
+host_os='linux-gnu'
+host_vendor='unknown'
+htmldir='${docdir}'
+includedir='${prefix}/include'
+infodir='${datarootdir}/info'
+libdir='${exec_prefix}/lib'
+libexecdir='${exec_prefix}/libexec'
+localedir='${datarootdir}/locale'
+localstatedir='${prefix}/var'
+mandir='${datarootdir}/man'
+oldincludedir='/usr/include'
+pdfdir='${docdir}'
+prefix='NONE'
+program_transform_name='s,x,x,'
+psdir='${docdir}'
+sbindir='${exec_prefix}/sbin'
+sharedstatedir='${prefix}/com'
+sysconfdir='${prefix}/etc'
+target='x86_64-unknown-linux-gnu'
+target_alias=''
+target_cpu='x86_64'
+target_os='linux-gnu'
+target_vendor='unknown'
+
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+
+/* confdefs.h */
+#define PACKAGE_NAME ""
+#define PACKAGE_TARNAME ""
+#define PACKAGE_VERSION ""
+#define PACKAGE_STRING ""
+#define PACKAGE_BUGREPORT ""
+#define PACKAGE_URL ""
+#define STDC_HEADERS 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_SYS_STAT_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRING_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_UNISTD_H 1
+#define __EXTENSIONS__ 1
+#define _ALL_SOURCE 1
+#define _GNU_SOURCE 1
+#define _POSIX_PTHREAD_SEMANTICS 1
+#define _TANDEM_SOURCE 1
+#define STDC_HEADERS 1
+#define HAVE_STRING_H 1
+#define HAVE_STL 1
+#define CPP_REQUIRES_NAMESPACE 1
+#define HAVE_TCL_H 1
+#define HAVE_TCLINT_H 1
+
+configure: exit 1
diff --git a/ns-2.35/indep-utils/cmu-scen-gen/setdest/calcdest b/ns-2.35/indep-utils/cmu-scen-gen/setdest/calcdest
new file mode 100755
index 0000000..f18c905
Binary files /dev/null and b/ns-2.35/indep-utils/cmu-scen-gen/setdest/calcdest differ
diff --git a/ns-2.35/tcl/ex/voip.tcl b/ns-2.35/tcl/ex/voip.tcl
new file mode 100644
index 0000000..cf27890
--- /dev/null
+++ b/ns-2.35/tcl/ex/voip.tcl
@@ -0,0 +1,459 @@
+# vim: syntax=tcl
+#
+
+##############################################################################
+#                       CONFIGURATION OF PARAMETERS                          #
+##############################################################################
+
+#
+# Simulation environment
+#
+set opt(run)        0         ;# replic ID
+set opt(duration)   100.0     ;# run duration, in seconds
+set opt(warm)       10.0       ;# run duration, in seconds
+set opt(out)        "out"     ;# statistics output file
+set opt(debug)      ""        ;# debug configuration file, "" = no debug
+set opt(startdebug) 100.0     ;# start time of debug output
+
+
+#
+# e2et Configuration
+#
+set opt(e2et-delay)          off      ;# If "on" let e2et to add delay
+set opt(e2et-delay-dir)      both       ;# Direction for which e2et adds delay
+set opt(e2et-delay-dst)      uniform  ;# Dst used to add delay
+set opt(e2et-delay-mean)     0.080      ;# Mean of dst
+set opt(e2et-delay-devstd)   0.050      ;# Standard Deviation of dst
+set opt(e2et-delay-min)      0.000      ;# Min of dst
+set opt(e2et-delay-max)      0.120      ;# Max of dst
+set opt(e2et-delay-b)        0.005      ;# B factor of laplacin distribution
+set opt(e2et-delay-reorder)  true       ;# If false avoid pkt reordering
+set opt(e2et-per)            0.0        ;# Add Packet Error Rate
+#
+# VoIP configuration
+#
+
+set opt(voip-bidirectional) 	     "on"        ;# VoIP bidirectional enable switch <on|off>
+set opt(voip-debug)		     "nodebug"	  ;# VoIP debug options - "debug" or "nodebug"
+set opt(voip-model)                  one-to-one   ;# VoIP VAD model
+set opt(voip-exponential-talk)       1            ;# Average talkspurt period duration, in sec, with exponential VAD model
+set opt(voip-exponential-silence)    1.5          ;# Average silence period duration, in sec, with exponential VAD model
+set opt(voip-codec)                  GSM.AMR      ;# VoIP codec
+set opt(voip-comp-hdr-size)          3            ;# header size, in bytes
+set opt(voip-aggr)                   2            ;# number of frames per packet
+set opt(voip-mos-threshold)          3.0          ;# to detect 'good' talkspurt
+set opt(voip-cell-mos-threshold)     0.75         ;# to measure cell satisfation
+set opt(voip-cell-loss-threshold)    0.02         ;# to measure cell outage
+set opt(voip-decoder-chain)          { optimal } ;# decoders
+# H323 configuration
+set opt(voip-decoder-min-jitter)     0.020        ;# H323 dejitter min jitter time (s)
+set opt(voip-decoder-max-jitter)     0.100	  ;# H323 dekitter max jitter time (s)
+#####################################################################################
+# Custom parameters for the Unidirectional VoIP model.
+# They are meaningful only if voip-model is set to weibull-custom.
+set opt(voip-talk-scale)      0.4122
+set opt(voip-talk-shape)      0.824
+set opt(voip-silence-scale)   0.899 
+set opt(voip-silence-shape)   1.089
+
+
+# static decoder parameters
+set opt(static-buffer)  20
+set opt(static-delay)   0.08
+
+##############################################################################
+#                       DEFINITION OF PROCEDURES                             #
+##############################################################################
+
+#
+# parse command-line options and store values into the $opt(.) hash
+#
+proc getopt {argc argv} {
+        global opt
+
+        for {set i 0} {$i < $argc} {incr i} {
+                set arg [lindex $argv $i]
+                if {[string range $arg 0 0] != "-"} continue
+
+                set name [string range $arg 1 end]
+                set opt($name) [lindex $argv [expr $i+1]]
+        }
+}
+
+#
+# print out options
+#
+proc printopt { } {
+        global opt
+
+        foreach x [lsort [array names opt]] {
+                puts "$x = $opt($x)"
+        }
+}
+
+#
+# die function
+#
+proc die { x } {
+        puts $x
+        exit 1
+}
+
+#
+# alive function
+#
+proc alive { } {
+        global ns opt
+
+        if { [$ns now] != 0 } {
+                puts -nonewline \
+                 [format "elapsed %.0f s (remaining %.0f s) completed %.f%%" \
+                 [$ns now] \
+                 [expr $opt(duration) - [$ns now]] \
+                 [expr 100 * [$ns now] / $opt(duration)]]
+                if { [$ns now] >= $opt(warm) } {
+                        puts " stat collection ON"
+                } else {
+                        puts ""
+                }
+        }
+        $ns at [expr [$ns now] + $opt(duration) / 10.0] "alive"
+}
+
+#
+# collect statistics at the end of the simulation
+#
+proc finish {} {
+        global ns simtime
+
+        # print statistics to output file
+        $ns stat print
+
+        # print out the simulation time
+        set simtime [expr [clock seconds] - $simtime]
+        puts "run duration: $simtime s"
+
+        exit 0
+}
+
+#
+# initialize simulation
+#
+proc init {} {
+        global opt defaultRNG ns simtime
+
+        # create the simulator instance
+        set ns [new Simulator]  ;# create a new simulator instance
+        $defaultRNG seed 1
+
+        # initialize statistics collection
+        $ns run-identifier $opt(run)
+        $ns stat file "$opt(out)"
+        $ns at $opt(warm) "$ns stat on"
+        $ns at $opt(duration) "finish"
+
+        # add default probes
+        $ns stat add e2e_owd_a    avg discrete
+        $ns stat add e2e_tpt      avg rate
+        $ns stat add e2e_owpl     avg rate
+        #$ns stat add tcp_cwnd_a   avg continuous
+        #$ns stat add tcp_dupacks  avg continuous
+        #$ns stat add tcp_ssthresh avg continuous
+        #$ns stat add tcp_rtt      avg continuous
+        #$ns stat add tcp_srtt     avg continuous
+
+        #$ns stat add tcp_cwnd_d   dst continuous 0 128 128
+        $ns stat add e2e_owd_d    dst discrete 0.0 1.0 1000
+        #$ns stat add e2e_ipdv_d   dst discrete 0.0 5.0 100 
+
+        $ns stat add voip_state_duration avg discrete
+	$ns stat add voip_frames_recv avg counter
+        $ns stat add voip_frames_sent avg counter
+        $ns stat add voip_cell_outage avg discrete
+        $ns stat add voip_mos_conversation avg discrete
+        $ns stat add voip_playout_talkspurt_delay avg discrete
+        $ns stat add voip_playout_talkspurt_per avg discrete
+        $ns stat add voip_satisfaction avg discrete
+        $ns stat add voip_cell_satisfaction avg discrete
+        $ns stat add voip_talkspurt_duration avg discrete
+	     $ns stat add voip_silence_duration avg discrete
+		  $ns stat add voip_dur_fid_silence avg discrete
+  		 
+
+        # open trace files
+        set opt(trace) [open "/dev/null" w]
+
+        set simtime [clock seconds]
+
+        $ns trace-all $opt(trace)
+}
+
+##############################################################################
+#                       SCENARIO CONFIGURATION                               #
+##############################################################################
+proc e2etConf { tag fid } {
+   global opt
+
+   $tag per $opt(e2et-per)
+
+   if { $opt(e2et-delay-dst) == "uniform" } {
+      set tag_ranvar [new RandomVariable/Uniform]
+      $tag_ranvar set min_ $opt(e2et-delay-min)
+      $tag_ranvar set max_ $opt(e2et-delay-max)
+
+   } elseif { $opt(e2et-delay-dst) == "exponential" } {
+      set tag_ranvar [new RandomVariable/Exponential]
+      $tag_ranvar set avg_ $opt(e2et-delay-mean)
+
+   } elseif { $opt(e2et-delay-dst) == "normal" } {
+      set tag_ranvar [new RandomVariable/Normal]
+      $tag_ranvar set avg_ $opt(e2et-delay-mean)
+      $tag_ranvar set std_ $opt(e2et-delay-devstd)
+
+   } elseif { $opt(e2et-delay-dst) == "lognormal" } {
+      set tag_ranvar [new RandomVariable/LogNormal] 
+      set mean $opt(e2et-delay-mean)
+      set stdd $opt(e2et-delay-devstd)   
+      $tag_ranvar set avg_ \
+         [expr log(pow($mean,2) / sqrt(pow($stdd,2) + pow($mean,2)))]
+      $tag_ranvar set std_ [expr sqrt(log(pow(($stdd / $mean),2) + 1))]
+
+   } elseif { $opt(e2et-delay-dst) == "constant" } {
+      set tag_ranvar [new RandomVariable/Constant]
+      $tag_ranvar set val_ $opt(e2et-delay-mean)
+   } elseif { $opt(e2et-delay-dst) == "threshold_uniform" } {
+      set tag_ranvar [new RandomVariable/Uniform]
+	if { $fid < $opt(e2et-threshold-fid) } {
+      		$tag_ranvar set min_  $opt(e2et-threshold-low)
+      		$tag_ranvar set max_  [expr $opt(e2et-threshold-window) * $opt(e2et-threshold-low) ]
+	} else {
+		$tag_ranvar set min_  $opt(e2et-threshold-high)
+      		$tag_ranvar set max_  [expr $opt(e2et-threshold-window) * $opt(e2et-threshold-high) ]
+	}
+   } else {
+      puts "Unknown distribution '%s'" $opt(e2et-delay-dst)
+      exit 0
+   }
+   if { $opt(e2et-delay)== "on" } {
+   	$tag ranvar $tag_ranvar 
+   	$tag reorder $opt(e2et-delay-reorder)
+   }
+#   $tag fid $fid
+}
+
+
+proc create_udp { n0 n1 fid app } {
+   global ns voip opt
+
+   set agtsrc [new Agent/UDP]
+   set agtdst [new Agent/UDP]
+
+   $agtsrc set fid_    $fid
+     
+   $agtsrc set packetSize_ 65535
+  
+   
+   set src $n0
+   set dst $n1
+   
+   $ns attach-agent $n0 $agtsrc
+   $ns attach-agent $n1 $agtdst
+   $ns connect $agtsrc $agtdst
+   if { $app == "voip" } {
+      $voip(encoder) attach-agent $agtsrc
+      $voip(decoder) attach-agent $agtdst
+      $voip(header)  attach-agent $agtsrc
+
+      if { $opt(voip-bidirectional) != "off" } {
+	  $voip(decoder) peer-id [expr $fid - 1] 
+      }
+   } else { 
+     puts "Application not supported"
+      exit 1
+   }
+
+   # end-to-end modules statistics collection
+   set tag [new e2et]
+   set mon [new e2em]
+   e2etConf $tag $fid
+   $agtsrc attach-e2et $tag
+   $agtdst attach-e2em $mon
+   $mon index $fid
+   $mon start-log
+
+	return 1
+}
+
+#
+# create a VoIP traffic flow between two nodes, agents included
+#
+proc create_voip { fid start stop } {
+   global opt ns voip bidirectional
+       # create a RNG for this application
+   set rng [new RNG]
+
+   # create and configure the VoIP application
+   set app [new VoipSource]
+
+  # create and configure voip bidirectional (if enabled)
+  if { $opt(voip-bidirectional) == "on" } {
+	  if { $opt(voip-model) != "one-to-one" } {
+		  puts "Bidirectional is available for 'one-to-one' conversations only!"
+		  exit 1
+	  }
+	      set bidirectional [new VoipBidirectionalModifiedBrady]
+		$ns at $start "$bidirectional start"
+	      if { $stop != "never" } {
+		$ns at $stop "$bidirectional stop"
+	      }
+	      ;# if { $opt(voip-bidir-debug) == "true" } { $bidirectional debug }
+	   $bidirectional source $app
+	   $app bidirectional $bidirectional
+
+  } elseif { $opt(voip-bidirectional) == "unrelated" } {
+	  if { $opt(voip-model) != "one-to-one" } {
+		  puts "Bidirectional is available for 'one-to-one' conversations only!"
+		  exit 1
+	  }
+	  # With one-to-one bidirectional model use a separate 
+	  # bidirectional object for each source.
+	  set bidirectional [new VoipBidirectionalModifiedBrady]
+	  $ns at $start "$bidirectional start"
+	  if { $stop != "never" } {
+		  $ns at $stop "$bidirectional stop"
+	  }
+	  $bidirectional source $app
+	  $app bidirectional $bidirectional
+  } elseif { $opt(voip-bidirectional) == "off" } { ;# VoIP bidirectional "off"
+	  # If voip-bidirectional is "on" or "unrelated"
+	  # then sources are started by bidirectional objects,
+	  # otherwise we start voip sources.				
+	  $ns at $start "$app start"
+	  if { $stop != "never" } { $ns at $stop "$app stop" }
+
+  } else {
+	  puts "Unknown value '$opt(voip-bidirectional)' for VoIP bidirectional"
+	  exit 1
+  }
+
+   if { $opt(voip-model) == "weibull-custom" } {
+      $app model $opt(voip-model) \
+         $opt(voip-talk-scale) $opt(voip-talk-shape) \
+         $opt(voip-silence-scale) $opt(voip-silence-shape)
+   } elseif { $opt(voip-model) == "exponential" } {
+      $app model $opt(voip-model) $opt(voip-exponential-talk) $opt(voip-exponential-silence)
+   } else {
+      $app model $opt(voip-model)
+   }
+
+   set header [new Application/VoipHeader]
+   $header compression $opt(voip-comp-hdr-size)
+   
+   set encoder [new Application/VoipEncoder]
+   
+   $encoder id $fid
+   $encoder codec $opt(voip-codec)
+   $encoder header $header
+   
+   ;# debug option
+   $encoder $opt(voip-debug)
+
+   $app encoder $encoder 
+   
+   # Create VoIPDecoder according to the chain 
+   
+   set n_dec [ llength $opt(voip-decoder-chain) ]
+
+   for { set idx [ expr $n_dec -1 ] } { $idx >= 0 } { incr idx -1 } {
+      
+      set decType [ lindex $opt(voip-decoder-chain) $idx ]
+      
+      if { $decType == "optimal" } {   
+         set decoder($idx) [new Application/VoipDecoderOptimal]
+         $decoder($idx) mos-threshold $opt(voip-mos-threshold)
+         $decoder($idx) cell-mos-threshold $opt(voip-cell-mos-threshold)
+         $decoder($idx) emodel $opt(voip-codec)
+      } elseif { $decType == "80216m" } {
+         set decoder($idx) [new Application/VoipDecoder80216m]
+         $decoder($idx) cell-loss-threshold $opt(voip-cell-loss-threshold)
+      } elseif { $decType == "atzori" } {
+         set decoder($idx) [new Application/VoipDecoderAtzori]
+         $decoder($idx) cell-loss-threshold $opt(voip-cell-loss-threshold)
+      } elseif { $decType == "h323" } {
+         set decoder($idx) [new Application/VoipDecoderH323]
+         $decoder($idx) cell-loss-threshold $opt(voip-cell-loss-threshold)
+	 $decoder($idx) min-jitter $opt(voip-decoder-min-jitter)
+	 $decoder($idx) max-jitter $opt(voip-decoder-max-jitter) 
+      } elseif { $decType == "static" } {
+         puts "Static decoder is DEPRECATED, abort"
+         exit 1
+      } else {
+         puts "Unknown decoder type $decType, abort"
+         exit 1
+      }
+      
+      # Common Configuration
+
+      $decoder($idx) id $fid
+      $decoder($idx) cell-id 0
+
+      ;# debug option
+      $decoder($idx) $opt(voip-debug)
+      
+      # Connect Decoder to the Chain
+      if { $idx < [ expr $n_dec -1 ] } {
+         $decoder($idx) next-decoder $decoder([ expr $idx+1 ])
+      }
+   }
+
+   set aggregate [new Application/VoipAggregate]
+   $aggregate nframes $opt(voip-aggr)
+   $aggregate header $header
+   $encoder aggregate $aggregate
+
+   set voip(encoder) $encoder
+   set voip(decoder) $decoder(0)
+   set voip(header)  $header
+
+   return $app
+}
+
+proc scenario {} {
+        global ns opt
+        set n0 [$ns node]
+        set n1 [$ns node]
+	set fid 1
+	set start 0
+	set stop 95
+        $ns duplex-link $n0 $n1 8Mb 10ms DropTail
+
+		  for { set i 0 } { $i < 1 } { incr i } {
+			  
+			  create_voip $fid $start $stop
+			  set f [create_udp $n0 $n1 $fid "voip"]
+			  if {$opt(voip-bidirectional) != "off"} {
+			      ;# create the opposite dir correlated flow
+			      create_voip [expr $fid+1] $start $stop
+			      create_udp $n1 $n0 [expr $fid+1] "voip"
+			      set f [expr $f+1]
+			  }
+
+
+		  }
+			 
+}	    
+
+
+##############################################################################
+#                            MAIN BODY                                       #
+##############################################################################
+
+getopt $argc $argv
+init
+scenario
+if { $opt(debug) != "" } {
+        printopt
+}
+alive
+
+$ns run
\ No newline at end of file
diff --git a/ns-2.35/tcl/lib/ns-agent.tcl b/ns-2.35/tcl/lib/ns-agent.tcl
index 4bcbb90..1913156 100644
--- a/ns-2.35/tcl/lib/ns-agent.tcl
+++ b/ns-2.35/tcl/lib/ns-agent.tcl
@@ -197,3 +197,26 @@ Agent/AOMDV set sport_   0
 Agent/AOMDV set dport_   0
 Agent/AOMDV set aomdv_prim_alt_path_len_diff_ 1
 Agent/AOMDV set aomdv_max_paths_ 3
+
+########################################################
+# Start of Measure Module extensions
+
+# Attach e2et to an agent
+#
+Agent instproc attach-e2et { e2et } {
+   $e2et target [$self target]
+   $self target $e2et
+
+}
+
+# Attach e2em to an agent
+#
+Agent instproc attach-e2em { e2em } {
+   set nd [$self set node_]
+   set pt [$self set agent_port_]
+   $nd add-target $e2em $pt
+   $e2em target $self
+}
+
+# End of Measure Module extensions
+########################################################
diff --git a/ns-2.35/tcl/lib/ns-default.tcl b/ns-2.35/tcl/lib/ns-default.tcl
index 56ee34f..c4f503e 100644
--- a/ns-2.35/tcl/lib/ns-default.tcl
+++ b/ns-2.35/tcl/lib/ns-default.tcl
@@ -634,7 +634,7 @@ NetworkInterface set debug_ false
 TBF set rate_ 64k
 TBF set bucket_ 1024
 TBF set qlen_ 0
-
+TBF set debug_ 0
 #
 # mobile Ip
 #
@@ -1590,3 +1590,11 @@ Agent/PBC set modulationScheme 0
 
 Agent/MDART set macFailed_ true
 Agent/MDART set etxMetric_ true
+
+#the following are added for the NS2Voip++
+e2em set debug_ 0
+e2et set debug_ 0
+timestamper set debug_ 0
+VoipSource set shape_ 1.0 
+VoipSource set scale_ 1.0
+Tracefile set debug_ false
diff --git a/ns-2.35/tcl/lib/ns-lib.tcl b/ns-2.35/tcl/lib/ns-lib.tcl
index af26e35..47e2d8a 100644
--- a/ns-2.35/tcl/lib/ns-lib.tcl
+++ b/ns-2.35/tcl/lib/ns-lib.tcl
@@ -2293,3 +2293,18 @@ Simulator instproc prepare-to-stop {} {
 	}
 }
     
+################################################
+# Start of MeMo extensions
+# timestamping at a node
+# installs a module that timestamps packets at a node
+
+Simulator instproc timestamper-install { n1 n2 timestamper } {
+   $self instvar link_
+   set headref [$link_([$n1 id]:[$n2 id]) head]
+   $timestamper target [$headref target]
+   $headref target $timestamper
+}
+
+# End of MeMo extensions
+################################################
+
diff --git a/ns-2.35/tcl/lib/ns-source.tcl b/ns-2.35/tcl/lib/ns-source.tcl
index 6769a4f..971d1a9 100644
--- a/ns-2.35/tcl/lib/ns-source.tcl
+++ b/ns-2.35/tcl/lib/ns-source.tcl
@@ -398,3 +398,15 @@ Source/Telnet instproc attach o {
 	$self attach-agent $o
 }
 
+#
+# For consistency with other applications
+#
+Class Source/VoipEncoder -superclass Application/VoipEncoder
+
+Source/VoipEncoder set maxpkts_ 268435456
+
+Source/VoipEncoder instproc attach o {
+       $self instvar agent_
+       set agent_ $o
+       $self attach-agent $o
+}
diff --git a/ns-2.35/tools/debug-tools.cc b/ns-2.35/tools/debug-tools.cc
new file mode 100644
index 0000000..427f32c
--- /dev/null
+++ b/ns-2.35/tools/debug-tools.cc
@@ -0,0 +1,98 @@
+/**
+   project: NS-2 Pisa
+   filename: debug-tools.cc
+	author: C. Cicconetti <c.cicconetti@iet.unipi.it>
+	        A. Erta <alessandro.erta@imtlucca.it>
+		A. Bacioccola <a.bacioccola@iet.unipi.it>
+	year: 2006
+   affiliation:
+      Dipartimento di Ingegneria dell'Informazione
+	   University of Pisa, Italy
+   description:
+	   Debug Tools Class
+ */
+
+// Debug Tools Includes
+#include <debug-tools.h>
+
+// NS-2 Includes
+#include <packet.h>
+#include <ip.h>
+
+// STL Includes
+#include <iostream>
+
+namespace Tools {
+        static class DebugClass : public TclClass {
+        public:
+                DebugClass() : TclClass("DebugTools") {}
+                TclObject* create(int, const char*const*) {
+                        return (new Debug);
+                }
+        } class_tools_debug;
+}
+
+#ifdef DEBUG_TOOLS
+
+char Tools::Debug::buf_[NBUFS][BUFSIZE];
+int Tools::Debug::cur_ = 0;
+bool Tools::Debug::enabled_ = true;
+std::map<std::string, bool> Tools::Debug::trace_;
+
+using namespace Tools;
+using namespace std;
+
+int
+Debug::command (int argc, const char*const* argv)
+{
+	if ( argc == 2 && strcmp (argv[1], "enable") == 0 ) {
+		enabled_ = true;
+		return TCL_OK;
+	} else if ( argc == 2 && strcmp (argv[1], "disable") == 0 ) {
+		enabled_ = false;
+		return TCL_OK;
+	} else if ( argc == 4 && strcmp (argv[1], "trace") == 0 ) {
+		bool status;
+
+		if ( strcmp (argv[3], "on") == 0 ) status = true;
+		else if ( strcmp (argv[3], "off") == 0 ) status = false;
+		else {
+			fprintf (stderr, "the trace status of function '%s' must be "
+					"either 'on' or 'off', not '%s'\n", argv[2], argv[3]);
+			return TCL_ERROR;
+		}
+
+		trace (argv[2], status);
+		return TCL_OK;
+	}
+
+	return TCL_ERROR;
+}
+
+char*
+Debug::format (Packet* pkt)
+{
+	char* b = buf_[cur_];
+	cur_ = ( cur_ + 1 == NBUFS ) ? 0 : ( cur_ + 1 );
+
+	snprintf (b, BUFSIZE, "IP fid %d prio %d size %d src %d dst %d uid %d",
+                        (HDR_IP(pkt))->flowid(),
+                        (HDR_IP(pkt))->prio(),
+                        (HDR_CMN(pkt))->size(),
+                        (HDR_IP(pkt))->saddr(),
+                        (HDR_IP(pkt))->daddr(),
+                        (HDR_CMN(pkt))->uid() );
+	return b;
+}
+
+#else
+
+using namespace Tools;
+
+int
+Debug::command (int argc, const char*const* argv)
+{
+	return TCL_OK;
+}
+
+#endif // DEBUG_TOOLS
\ No newline at end of file
diff --git a/ns-2.35/tools/debug-tools.h b/ns-2.35/tools/debug-tools.h
new file mode 100644
index 0000000..3d1fc49
--- /dev/null
+++ b/ns-2.35/tools/debug-tools.h
@@ -0,0 +1,108 @@
+/**
+   project: NS-2 Pisa
+   filename: debug-tools.h
+	author: C. Cicconetti <c.cicconetti@iet.unipi.it>
+	        A. Erta <alessandro.erta@imtlucca.it>
+		A. Bacioccola <a.bacioccola@iet.unipi.it>
+	year: 2006
+   affiliation:
+      Dipartimento di Ingegneria dell'Informazione
+	   University of Pisa, Italy
+   description:
+	   Debug Tools Class
+*/
+
+#ifndef __NS2_DEBUG_TOOLS_H
+#define __NS2_DEBUG_TOOLS_H
+
+// NS-2 Includes
+#include <packet.h> //! \todo Includere il file per la classe TclObject!
+
+// STL Includes
+#include <list>
+#include <map>
+#include <stdio.h>
+#include <string>
+#include <vector>
+
+//! This macro can be used to hard-disable debug and save computational time
+#define DEBUG_TOOLS
+
+#ifdef DEBUG_TOOLS
+namespace Tools {
+        //! Useful debug static class.
+        /*!
+        The 'format' functions return a single-line (non-'\n' terminated) sequence.
+
+        On the other hand, the 'print' functions print a longer description
+        on a given output stream file. An optional argument allows the caller
+        to specify a string that has to be added at the beginning of each line.
+        */
+        class Debug : public TclObject {
+                enum { NBUFS = 10 };
+                enum { BUFSIZE = 1024 };
+                //! Static buffer returned by format functions.
+                static char buf_[NBUFS][BUFSIZE];
+                //! Current buffer.
+                static int cur_;
+                //! True if debug is enabled.
+                static bool enabled_;
+                //! Map of function names to flag (true means this function is traced).
+                static std::map<std::string, bool> trace_;
+
+        public:
+                //! Do nothing.
+                Debug () { }
+                //! Do nothing.
+                virtual ~Debug () { }
+
+                //! Print a line with
+                /** ns2 packet information.
+                 */
+                static char* format ( Packet* pkt );
+
+                //! Get/set the enabled flag.
+                static bool& enabled () { return enabled_; }
+
+                //! Return true if this function is traced and debug is enabled.
+                static bool trace (const char* f) {
+                        return ( enabled_ &&
+                                 trace_.count(std::string(f)) == 1 &&
+                                 trace_[std::string(f)] == true ) ? true : false;
+                }
+
+                //! Set the trace true/false status of a function name.
+                static void trace (const char* f, bool status) {
+                        trace_[std::string(f)] = status;
+                }
+
+        protected:
+                //! Tcl interface.
+                virtual int command (int argc, const char*const* argv);
+        };
+}
+
+#else
+
+namespace Tools {
+
+        class Debug : public TclObject {
+        public:
+                Debug () { }
+                virtual ~Debug () { }
+
+                static char* format ( Packet* pkt ){return "";}
+
+                static bool enabled () { return false; }
+                static bool trace (const char* f) { return false; }
+                static void trace (const char* f, bool status) { }
+
+        protected:
+
+                virtual int command (int argc, const char*const* argv);
+        };
+
+}
+#endif // DEBUG_TOOLS
+
+#endif // __NS2_DEBUG_TOOLS_H
diff --git a/ns-2.35/tools/e2em.cc b/ns-2.35/tools/e2em.cc
new file mode 100644
index 0000000..54f1e2d
--- /dev/null
+++ b/ns-2.35/tools/e2em.cc
@@ -0,0 +1,476 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+
+/* End to End Monitor connector
+   This code has been developed within the EuQoS project of the EU IST 6th Framework Programme. 
+   The "end to end monitor" connector sits between a receiving agent and the node the latter is attached to. 
+
+   For every packet sent TO the agent, it checks the following EuQoS extension fields, set by a companion 
+   "End to End Tagger" agent (see e2et.{cc.h}), in the common header:
+   - e2e_ts_ : end-to-end timestamp, which stores the time at which the packet was transmitted
+   - e2e_sn_ : end-to-end sequence number, starting from 0
+
+   The e2em end connector computes delay, e2e_jitter, throughput and packet loss ratio statistics.
+   Furthermore, it can log the above measures on separate files.
+
+   Giovanni Stea (g.stea@iet.unipi.it), University of Pisa, Italy, January 2005. 
+
+   ------
+   CAVEAT (July 2005)
+   The measurement connectors have been tested to work with Token Bucket filter (which is a connector itself). In that case, 
+   the RELATIVE order in which the attach-e2et and attach-tbf operations are performed determines whether the queueing delay of the TBF
+   is/is not counted in the e2e delay. More specifically, the *last* attach- operation attaches the connector which is closest to the agent.
+
+   ------
+   UPDATE (March 2006)
+   Modified as follows: rather than one timestamp, an ARRAY of timestamps is provisioned. The e2e tagger sets the FIRST timestamp in the array.
+   Other timestamps can be set by the timestamper connector (see timestamper.cc), whch sits at the ingress of a link. This way, the e2e monitor 
+   can compute the delay and jitter contribution of sub-paths in an e2e path.
+
+*/
+
+#define DEBUG(x);
+
+#include <e2em.h>
+#include <stat.h>
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// END TO END MONITOR TIMER CLASS
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void e2em_Timer::init (e2em* e2emconn, int me, double interv)
+{
+	if (me<0 || me >= NoMeasures)
+	{
+
+	}
+
+	e2em_= e2emconn;
+	m_=me;
+	interval_=interv;
+
+}
+
+void e2em_Timer::settimeout (double d)
+{
+	if (d<=0.)
+	{
+		fprintf (stderr, "\n\nERROR: e2em_Timer::settimeout (Interval=%g). \nAveraging interval must be greater than zero. \nAborting at time %g...\n", 
+			 d, Scheduler::instance().clock());
+		exit (-1);
+	}
+
+	interval_=d;
+}
+
+
+double e2em_Timer::gettimeout (void)
+{
+	return interval_;
+}
+
+
+void e2em_Timer::expire(Event* /*e*/)
+{
+	e2em_->timeout(m_);
+}
+
+
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// END TO END MONITOR CLASS
+//
+/////////////////////////////////////////////////////////////////////////////
+
+
+e2em::e2em()
+{
+	for (int i=0; i<NoMeasures; i++)
+	{
+		measure[i].timer = new (e2em_Timer);
+		measure[i].timer->init(this, i, 5.);
+		measure[i].active =0;
+		measure[i].interval =5.;
+		measure[i].sum=0;
+		measure[i].sample_no=0;
+		measure[i].tracefile=NULL;
+		strcpy(measure[i].filename, "\0");
+	}
+
+	measure[OWD].name="OWD";
+	measure[IPDV].name="IPDV";
+	measure[IPT].name="IPT";
+	measure[OWPL].name="OWPL";	
+
+	for (int j=0; j<TSTAMP_NO; j++) last_packet_delay[j]=-1.;
+	last_packet_e2e_delay=-1.;
+	next_expected=0;
+
+	static int nextIndex = 0;
+	index_ = nextIndex++;
+
+	fairnessEstimator_ = 0;
+
+	reset_stats();
+}
+	
+
+
+void e2em::recv(Packet *p, Handler *)
+{
+	double now= Scheduler::instance().clock();
+	hdr_cmn* cmn = hdr_cmn::access(p);	
+
+	int out_of_seq, ts_no;
+	double del[TSTAMP_NO], e2e_del, e2e_jit;
+
+
+	// check sequence number and compute out-of-sequence	
+	// :TODO: manage wrap-around of the sequence numbers
+	out_of_seq=cmn->e2e_sn()-next_expected;
+	next_expected=cmn->e2e_sn()+1;	
+
+	DEBUG(
+		if (out_of_seq<0)
+			fprintf (stderr, "\nInternal error at time %g: expected packet %d, arrived %d.\n", now, next_expected, cmn->e2e_sn());
+	);
+
+
+	// compute e2e delay and jitter
+	e2e_del = now-cmn->e2e_timestamp(0);
+	e2e_jit = last_packet_e2e_delay>=0? last_packet_e2e_delay-e2e_del : 0;
+	last_packet_e2e_delay=e2e_del;
+
+	// add a delay sample
+	Stat::put ("e2e_owd_a", index_, e2e_del);
+	Stat::put ("e2e_owd_d", index_, e2e_del);
+
+	// add a jitter sample if the last packet was received in order
+	if ( out_of_seq == 0 ) Stat::put ("e2e_ipdv_d", index_, e2e_jit);
+
+	
+	DEBUG(
+		if (e2e_del<0.)
+			fprintf (stderr, "\nInternal error at time %g: packet left at %g and arrived at %g.\n", now, cmn->e2e_timestamp(0), now);
+	);
+		
+
+	if (measure[OWD].active || measure[IPDV].active)
+	{
+		/* Stea, March 2006
+	 	the e2e tagger and monitor can also compute per-subpath delays and jitter. Every link can timestamp the packet on arrival, 
+		(provided a timestamp connector is attached to it), and the e2e monitor parses all the timestamps and writes the 
+		delays and jitter to a file. The first timestamp is put by the e2e tagger. The delays and jitter are written as follows:
+		<arrival time> <e2e del/jit> <del/jit from e2et to 1st timestamper> <del/jit from 1st to 2nd timestamper> [...] <del/jit from last timestamper to e2em>
+		*/
+
+		ts_no=cmn->e2e_timestamp_no();	
+
+		for (int ts=0; ts<ts_no-1; ts++)
+		{
+			// per subpath delays
+			del[ts] = cmn->e2e_timestamp(ts+1)-cmn->e2e_timestamp(ts);
+	
+			DEBUG(
+				if (del[ts]<0)
+					fprintf (stderr, "\nInternal error at time %g (computing partial delays): packet left at %g and arrived at %g.\n", now, cmn->e2e_timestamp(), cmn->e2e_timestamp(ts+1));
+				);
+		}
+		if (ts_no>1)
+			del[ts_no-1]=now-cmn->e2e_timestamp(ts_no-1);
+	
+		// write down packet-wise measures
+		/*
+		if (measure[OWD].active)
+		{
+			fprintf (measure[OWD].tracefile, "%g\t%g", now, e2e_del);
+			if (ts_no>1)
+				for (int no=0; no<ts_no; no++)
+					fprintf (measure[OWD].tracefile, "\t%g", del[no]);
+			fprintf (measure[OWD].tracefile, "\n");
+		}
+	
+		if (measure[IPDV].active)
+		{
+			fprintf (measure[IPDV].tracefile, "%g\t%g", now, e2e_jit);
+			if (ts_no>1)
+				for (int no=0; no<ts_no; no++)
+					fprintf (measure[IPDV].tracefile, "\t%g", (last_packet_delay[no]>=0.)?last_packet_delay[no]-del[no]:0.);
+			fprintf (measure[IPDV].tracefile, "\n");
+		}
+		*/
+
+		for (int j=0; j<ts_no; j++) last_packet_delay[j]=del[j];
+	}
+
+
+	// update time-averaged measures
+	if (measure[IPT].active)
+	{
+		measure[IPT].sum+=cmn->size();
+		measure[IPT].sample_no++;
+		Stat::put ("e2e_tpt", index_, cmn->size());
+		if ( fairnessEstimator_ ) fairnessEstimator_->put (cmn->size(), index_);
+	}
+
+	if (measure[OWPL].active)
+	{
+		measure[OWPL].sum+= out_of_seq;
+		measure[OWPL].sample_no+=out_of_seq+1;
+		Stat::put ("e2e_owpl", index_, out_of_seq);
+	}
+	
+	// update statistics
+	statistics.arrived++;
+	statistics.bytesum+=cmn->size();
+	statistics.lostp+=out_of_seq; 
+
+	statistics.stat[OWD].min = e2e_del<statistics.stat[OWD].min ? e2e_del : statistics.stat[OWD].min;
+	statistics.stat[OWD].max = e2e_del>statistics.stat[OWD].max ? e2e_del : statistics.stat[OWD].max;
+	statistics.stat[OWD].sum += e2e_del;
+	statistics.stat[OWD].sqsum += e2e_del*e2e_del;
+
+	statistics.stat[IPDV].min = e2e_jit<statistics.stat[IPDV].min ? e2e_jit : statistics.stat[IPDV].min;
+	statistics.stat[IPDV].max = e2e_jit>statistics.stat[IPDV].max ? e2e_jit : statistics.stat[IPDV].max;
+	statistics.stat[IPDV].sum += e2e_jit;
+	statistics.stat[IPDV].sqsum += e2e_jit*e2e_jit;
+
+	// handle the packet to the receiving agent
+	target_->recv(p);
+
+}
+
+
+void e2em::timeout(int i)
+{
+	if (i>=0 && i<IPT) return;	// shouldn't ever occur...
+
+	double now= Scheduler::instance().clock();
+
+	if (i>=NoMeasures || i<0)
+	{
+		fprintf(stderr, "\n\nERROR: e2em::timeout (%d). Unknown measure id. Should be between 0 and %d:\n", i, NoMeasures-1);
+		fprintf (stderr, "\nAborting at time %g\n", now);
+		exit (-1);
+	}
+
+	if (measure[i].active)		// "active" could have been reset while the timer was running. In that case, the file would not be open.
+	{
+		double deltat=measure[i].timer->gettimeout();
+		// write down on the tracefile the relevant time-averaged measure
+		/*
+		if (i==IPT)
+			fprintf (measure[i].tracefile, "%g\t%g\t%g\n", now, 
+				measure[i].sum/deltat, measure[i].sample_no/deltat);
+		else if (i==OWPL)
+			fprintf (measure[i].tracefile, "%g\t%g\n", now, 
+				 measure[i].sample_no>0 ? measure[i].sum/measure[i].sample_no : 0.);
+				 */
+
+		// reset the counters
+		measure[i].sum=0.;
+		measure[i].sample_no=0;
+
+		// restart the timer
+		measure[i].timer->settimeout(measure[i].interval);	// the latter might have been changed while the timer was running
+		measure[i].timer->resched(measure[i].interval);
+	}
+}
+
+
+int e2em::string2measure (const char* const meas)
+{
+	int i;
+	for (i=0; i<NoMeasures; i++)
+	if (!strcmp (meas, measure[i].name)) return i;
+
+	fprintf(stderr, "\n\nERROR: e2em::string2measure (%s). Unknown measure. Those available are:\n", meas);
+	for (i=0; i<NoMeasures; i++)
+		fprintf(stderr, "%s\t",measure[i].name);
+	fprintf (stderr, "\nAborting at time %g\n", Scheduler::instance().clock());
+	exit (-1);
+}
+
+
+void e2em::write_stats(void)
+{
+	double deltat = Scheduler::instance().clock()-statistics.left_edge;
+	fprintf (stdout, "\nFrom time %g to time %g", statistics.left_edge, Scheduler::instance().clock());
+	fprintf (stdout, "\nArrived %d packets (%g bytes)", statistics.arrived, statistics.bytesum);
+	fprintf (stdout, "\nPacket Loss %g %%; throughput %g bits per second, (%g packets per second)", 
+				(statistics.arrived>0 ? statistics.lostp/((double)statistics.arrived+statistics.lostp) : 0), 
+				(deltat>0? statistics.bytesum/deltat : 0),
+				(deltat>0? statistics.arrived/deltat : 0));
+
+	for (int i=0; i<2; i++)
+		fprintf (stdout, "\n%s - Min %g; Avg %g; Max %g; SqAvg %g", measure[i].name,
+			(statistics.arrived>0 ? statistics.stat[i].min : 0),  
+			(statistics.arrived>0 ? statistics.stat[i].sum/(double)statistics.arrived : 0),
+			(statistics.arrived>0 ? statistics.stat[i].max : 0),
+			(statistics.arrived>0 ? (statistics.stat[i].sqsum)/(double)statistics.arrived : 0));
+
+	fprintf (stdout, "\n");
+	fflush (stdout);
+}
+
+
+void e2em::reset_stats(void)
+{
+	
+	statistics.left_edge=Scheduler::instance().clock();
+	statistics.arrived=0;
+	statistics.bytesum=0.;
+	statistics.lostp=0;
+
+	for (int j=0; j<IPT; j++)
+	{
+		statistics.stat[j].min=1e10;
+		statistics.stat[j].max=-1e10;
+		statistics.stat[j].sum=0;
+		statistics.stat[j].sqsum=0;
+	}
+}
+
+
+void e2em::start_log (const char* const meas)
+{
+	int i= string2measure(meas);
+	
+	DEBUG (		
+		fprintf (stdout, "\n\nStart log measure %d, which is now active=%d\n\n", i, measure[i].active);
+		);
+
+	if (!measure[i].active)	// otherwise do nothing
+	{
+		// measure[i].tracefile = fopen (measure[i].filename, "a+");
+		measure[i].active =1;
+		measure[i].sum=0;
+		measure[i].sample_no=0;
+
+		for (int j=0; j<TSTAMP_NO; j++) last_packet_delay[j]=-1.;
+		last_packet_e2e_delay=-1.;
+	
+		if (i>=IPT)	// timer is only to be activated for time-averaged measures
+		{
+			measure[i].timer->settimeout(measure[i].interval);
+			measure[i].timer->resched(measure[i].interval);
+		}
+	}
+}
+
+
+void e2em::stop_log (const char* const meas)
+{
+	int i= string2measure(meas);
+
+	DEBUG (		
+		fprintf (stdout, "\n\nStop log measure %d, which is now active=%d\n\n", i, measure[i].active);
+		);
+
+	if (measure[i].active)	// otherwise do nothing
+	{
+		// fclose(measure[i].tracefile);
+		measure[i].active =0;
+
+		// timer NOT to be stopped here (rather, check the active flag at next timeout)
+	}
+}
+
+
+void e2em::attach_file (const char* const meas, const char* const fname)
+{
+	int i= string2measure(meas);
+	strcpy (measure[i].filename, fname);
+	// measure[i].tracefile = fopen (measure[i].filename, "w");
+	// fclose(measure[i].tracefile);
+}
+
+
+void e2em::set_interval (const char* const meas, double interval)
+{
+	int i= string2measure(meas);
+
+	if (interval <=0.)
+	{
+		fprintf (stderr, "\n\nERROR: e2em::set_interval (string, Interval=%g). \nAveraging interval must be greater than zero. \nAborting at time %g...\n", 
+			 interval, Scheduler::instance().clock());
+		exit (-1);
+	}
+
+	measure[i].interval=interval;
+}
+
+
+int e2em::command(int argc, const char*const* argv)
+{
+	if (argc == 2) {
+		if (strcmp(argv[1], "get-stats") == 0) {
+			write_stats();
+			return (TCL_OK);
+		}
+		if (strcmp(argv[1], "reset-stats") == 0) {
+			reset_stats();
+			return (TCL_OK);
+		}
+		if (strcmp(argv[1], "start-log") == 0) {
+			start_log ("IPT");
+			start_log ("OWD");
+			start_log ("OWPL");
+			start_log ("IPDV");
+			return (TCL_OK);
+		}
+	}
+	else if (argc==3)
+	{
+		if (strcmp(argv[1], "fairness-estimator") == 0) {
+			fairnessEstimator_ = (FairnessEstimator*) TclObject::lookup(argv[2]);
+			return (TCL_OK);
+		}
+		if (strcmp(argv[1], "index") == 0) {
+			index_ = atoi (argv[2]);
+			return (TCL_OK);
+		}
+		if (strcmp(argv[1], "start-log") == 0) {
+			start_log (argv[2]); 
+			return (TCL_OK);
+		}
+		if (strcmp(argv[1], "stop-log") == 0) {
+			stop_log (argv[2]); 
+			return (TCL_OK);
+		}
+	}
+
+	else if (argc==4)
+	{
+		if (strcmp(argv[1], "attach-file") == 0) {
+			attach_file (argv[2], argv[3]); 
+			return (TCL_OK);
+		}
+		if (strcmp(argv[1], "set-interval") == 0) {
+			set_interval (argv[2], atof(argv[3])); 
+			return (TCL_OK);
+		}
+	}
+	return (Connector::command(argc, argv));
+}
+
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// END TO END MONITOR - OTCL LINKAGE
+//
+/////////////////////////////////////////////////////////////////////////////
+
+
+static class e2emClass : public TclClass {
+public:
+	e2emClass() : TclClass ("e2em") {}
+	TclObject* create(int,const char*const*) {
+		return (new e2em());
+	}
+}class_e2em;
diff --git a/ns-2.35/tools/e2em.h b/ns-2.35/tools/e2em.h
new file mode 100644
index 0000000..7e8a948
--- /dev/null
+++ b/ns-2.35/tools/e2em.h
@@ -0,0 +1,138 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+
+/* End to End Monitor connector
+   This code has been developed within the EuQoS project of the EU IST 6th Framework Programme. 
+   The "end to end monitor" connector sits between a receiving agent and the node the latter is attached to. 
+
+   For every packet sent TO the agent, it checks the following EuQoS extension fields, set by a companion 
+   "End to End Tagger" agent (see e2et.{cc.h}), in the common header:
+   - e2e_ts_ : end-to-end timestamp, which stores the time at which the packet was transmitted
+   - e2e_sn_ : end-to-end sequence number, starting from 0
+
+   The e2em end connector computes delay, jitter, throughput and packet loss ratio statistics.
+   Furthermore, it can log the above measures on separate files.
+
+   Giovanni Stea (g.stea@iet.unipi.it), University of Pisa, Italy, January 2005. 
+
+   ------
+   UPDATE (July 2005)
+   Modified as follows: rather than one timestamp, an ARRAY of timestamps is provisioned. The e2e tagger sets the FIRST timestamp in the array.
+   Other timestamps can be set by the timestamper connector (see timestamper.cc), whch sits at the ingress of a link. This way, the e2e monitor 
+   can compute the delay contribution of sub-paths in an e2e path.
+
+   ------
+   CAVEAT (July 2005)
+   The measurement connectors have been tested to work with Token Bucket filter (which is a connector itself). In that case, 
+   the RELATIVE order in which the attach-e2et and attach-tbf operations are performed determines whether the queueing delay of the TBF
+   is/is not counted in the e2e delay. More specifically, the *last* attach- operation attaches the connector which is closest to the agent.
+
+*/
+
+
+
+#ifndef ns_e2em_h
+#define ns_e2em_h
+
+#include <fairness.h>
+#include <connector.h>
+#include <config.h>
+#include <packet.h>
+#include <timer-handler.h>
+
+class e2em;
+
+enum MeasureID {OWD=0, IPDV=1, IPT=2, OWPL=3, NoMeasures};
+// OWD= One-Way Delay
+// IDPV = Inter-Packet Delay Variation
+// IPT = IP Throughput
+// OWPL = One-Way Packet Loss
+// NB: if needed, add extra measures BEFORE NoMeasures. Leave NoMeasures as the last item.
+// NB2: in case MORE measures are added, leave IPT as the *first* time-averaged measures
+
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// END TO END MONITOR TIMER CLASS
+//
+/////////////////////////////////////////////////////////////////////////////
+
+
+class e2em_Timer : public TimerHandler {
+public:
+	e2em_Timer() : TimerHandler() {};
+	void init (e2em*, int, double);
+	void settimeout (double);
+	double gettimeout (void);
+
+
+protected:
+	virtual void expire(Event *e);
+	e2em* e2em_;	
+	int m_;		// # of the measure to which the timer is associated
+	double interval_;	// # timer interval
+};
+
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// END TO END MONITOR CLASS
+//
+/////////////////////////////////////////////////////////////////////////////
+
+class e2em : public Connector {
+public:
+	e2em();
+	void timeout(int);
+
+protected:
+	virtual int command(int argc, const char*const* argv);
+	virtual void recv(Packet *, Handler *);
+	e2em_Timer e2em_timer_;
+
+private:
+	void write_stats(void);
+	void reset_stats(void);
+	void start_log (const char* const);
+	void stop_log (const char* const);
+	void attach_file (const char* const, const char* const);
+	void set_interval (const char* const, double);
+	int string2measure (const char* const);
+
+struct Measure  {char* name;
+		 e2em_Timer* timer;
+		 FILE* tracefile;
+		 char filename[100];
+		 int active;
+		 double interval;	// meaningful only for time-averaged measures
+		 double sum;		// meaningful only for time-averaged measures
+		 int sample_no;		// meaningful only for time-averaged measures
+		} measure[NoMeasures];
+
+
+struct StatDesc	{ double min;
+		  double max;
+		  double sum;
+		  double sqsum;
+		};
+
+struct Statistics {				// those appearing as output of "get-stat"
+		 
+		  double left_edge;		// left edge of the time window
+		  int arrived;
+		  double bytesum;
+		  int lostp;
+		  struct StatDesc stat[IPT];
+		} statistics;
+
+double 	last_packet_delay[TSTAMP_NO],	// used for computing jitter on a packet arrival.
+	last_packet_e2e_delay;			
+int next_expected;			// used for checking losses
+	int index_;             // used to set the ID in the Stat measures
+	                        // can be changed via Tcl command
+	FairnessEstimator* fairnessEstimator_;  // fairness estimator object
+
+};
+
+#endif
diff --git a/ns-2.35/tools/e2et.cc b/ns-2.35/tools/e2et.cc
new file mode 100644
index 0000000..2f3ce38
--- /dev/null
+++ b/ns-2.35/tools/e2et.cc
@@ -0,0 +1,93 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+
+/* End to End Tagger connector
+   This code has been developed within the EuQoS project of the EU IST 6th Framework Programme. 
+   The "end to end tagger" connector sits between a sending agent and the node the latter is attached to. 
+
+   For every packet sent BY the agent, it sets the following extension fields in the common header:
+   - e2e_ts_ : e2e timestamp, set to the current clock
+   - e2e_sn_ : e2e sequence number, starting from 0
+
+   This way, a companion "end to end monitor" connector (see e2em.{cc.h}), sitting between the receiving node
+   and the receiving agent, can use the above information to compute delay, jitter, throughput and packet loss
+   ratio statistics.
+
+   Giovanni Stea (g.stea@iet.unipi.it), University of Pisa, Italy, January 2005. 
+
+   ------
+   UPDATE (July 2005)
+   Modified as follows: rather than one timestamp, an ARRAY of timestamps is provisioned. The e2e tagger sets the FIRST timestamp in the array.
+   Other timestamps can be set by the timestamper connector (see timestamper.cc), whch sits at the ingress of a link. This way, the e2e monitor 
+   can compute the delay contribution of sub-paths in an e2e path.
+
+   ------
+   CAVEAT (July 2005)
+   The measurement connectors have been tested to work with Token Bucket filter (which is a connector itself). In that case, 
+   the RELATIVE order in which the attach-e2et and attach-tbf operations are performed determines whether the queueing delay of the TBF
+   is/is not counted in the e2e delay. More specifically, the *last* attach- operation attaches the connector which is closest to the agent.
+*/
+
+#include <connector.h>
+#include <packet.h>
+#include "e2et.h"
+
+/* Stea, June 2005
+ the e2e tagger and monitor can compute per-path subdelays. Every node can timestamp the packet on arrival, and the
+e2e monitor collects them all and puts them into a file. The first timestamp is put by the e2e tagger.
+*/
+
+static class e2etClass : public TclClass {
+public:
+	e2etClass() : TclClass ("e2et") {}
+	TclObject* create(int,const char*const*) {
+		return (new e2et());
+	}
+} class_e2et;
+
+e2et::e2et () : loss_(0.0, 1.0), timer_(this)
+{
+	sn_     = 0;
+	ranvar_ = 0;
+	per_    = 0;
+}
+
+int
+e2et::command (int argc, const char*const* argv)
+{
+	if ( argc == 3 && strcmp (argv[1], "ranvar") == 0 ) {
+		ranvar_ = (RandomVariable*) TclObject::lookup (argv[2]);
+		return TCL_OK;
+	} else if ( argc == 3 && strcmp (argv[1], "per") == 0 ) {
+		per_ = atof (argv[2]);
+		if ( per_ < 0 ) {
+			fprintf (stderr, "Invalid packet error rate '%f'\n", per_);
+			return TCL_ERROR;
+		}
+		return TCL_OK;
+	}
+	return Connector::command (argc, argv);
+}
+
+void
+e2et::recv(Packet *p, Handler *)
+{
+	hdr_cmn *ch = hdr_cmn::access(p);
+	ch->e2e_timestamp_no() = 0;
+	ch->e2e_timestamp(0) = Scheduler::instance().clock();
+	ch->e2e_sn() = sn_++;
+	ch->e2e_timestamp_no()++;
+	if ( per_ == 0 || loss_.value() > per_ ) {
+		if ( ! ranvar_ ) handle (p);
+		else {
+			double jitter = ranvar_->value();
+			timer_.add ( ( jitter > 0 ) ? jitter : 0, p);
+		}
+	} else
+		Packet::free (p);
+}
+
+void
+e2et::handle (Packet* p)
+{
+	target_->recv(p);
+}
diff --git a/ns-2.35/tools/e2et.h b/ns-2.35/tools/e2et.h
new file mode 100644
index 0000000..c5ecf79
--- /dev/null
+++ b/ns-2.35/tools/e2et.h
@@ -0,0 +1,71 @@
+/* -*-	Mode:C++; c-basic-offset:8; tab-width:8; indent-tabs-mode:t -*- */
+
+/* End to End Tagger connector
+   This code has been developed within the EuQoS project of the EU IST 6th Framework Programme. 
+   The "end to end tagger" connector sits between a sending agent and the node the latter is attached to. 
+
+   For every packet sent BY the agent, it sets the following extension fields in the common header:
+   - e2e_ts_ : end-to-end timestamp, set to the current clock
+   - e2e_sn_ : end-to-end sequence number, starting from 0
+
+   This way, a companion "end to end monitor" connector (see e2em.{cc.h}), sitting between the receiving node
+   and the receiving agent, can use the above information to compute delay, jitter, throughput and packet loss
+   ratio statistics.
+
+   Giovanni Stea (g.stea@iet.unipi.it), University of Pisa, Italy, January 2005. 
+
+   ------
+   UPDATE (July 2005)
+   Modified as follows: rather than one timestamp, an ARRAY of timestamps is provisioned. The e2e tagger sets the FIRST timestamp in the array.
+   Other timestamps can be set by the timestamper connector (see timestamper.cc), whch sits at the ingress of a link. This way, the e2e monitor 
+   can compute the delay contribution of sub-paths in an e2e path.
+
+   ------
+   CAVEAT (July 2005)
+   The measurement connectors have been tested to work with Token Bucket filter (which is a connector itself). In that case, 
+   the RELATIVE order in which the attach-e2et and attach-tbf operations are performed determines whether the queueing delay of the TBF
+   is/is not counted in the e2e delay. More specifically, the *last* attach- operation attaches the connector which is closest to the agent.
+*/
+
+
+#ifndef ns_e2et_h
+#define ns_e2et_h
+
+#include <connector.h>
+#include <ranvar.h>
+#include <t_timers.h>
+
+class e2et : public Connector {
+public:
+	//! Create a defaul end-to-end tagger, with no additional delay.
+	e2et();
+	
+	//! Receive a packet from the upper layer entity.
+	void recv(Packet *, Handler *);
+
+	//! Tcl interface.
+	virtual int command (int argc, const char*const* argv);
+
+	//! Send the packet to the down target.
+	void handle (Packet* p);
+	
+protected:
+
+	//! Current sequence number.
+	int sn_;
+
+	//! Random variable to add delay.
+	RandomVariable* ranvar_;
+
+	//! Random variable to get packets lost.
+	UniformRandomVariable loss_;
+
+	//! Packet error rate. Set via Tcl.
+	double per_;
+
+	//! Timer to delay packets randomly.
+	TMultiTimer<e2et, Packet*> timer_;
+};
+
+#endif
+
diff --git a/ns-2.35/tools/fairness.cc b/ns-2.35/tools/fairness.cc
new file mode 100644
index 0000000..1f2b6a8
--- /dev/null
+++ b/ns-2.35/tools/fairness.cc
@@ -0,0 +1,137 @@
+/**
+   project: measure
+   filename: fairness.cc
+   author: C. Cicconetti <c.cicconetti@iet.unipi.it>
+   year: 2006
+   affiliation:
+      Dipartimento di Ingegneria dell'Informazione
+      University of Pisa, Italy
+   description:
+      Fairness measures collection module
+*/
+
+#include <fairness.h>
+
+#include <stat.h>
+
+static class FairnessEstimatorClass : public TclClass {
+public:
+   FairnessEstimatorClass() : TclClass("FairnessEstimator") {}
+   TclObject* create(int, const char*const*) {
+      return (new FairnessEstimator);
+   }
+} class_fairness_estimator;
+
+
+FairnessEstimator::FairnessEstimator () : timer_ (this)
+{
+	actors_ = 0;
+	firstId_ = 0;
+}
+
+int
+FairnessEstimator::command (int argc, const char*const* argv)
+{
+	if ( argc == 3 && strcmp (argv[1], "actors") == 0 ) {
+		if ( actors_ > 0 ) {
+			fprintf (stderr, "You cannot change the number of actors\n");
+			return TCL_ERROR;
+		} else if ( atoi(argv[2]) <= 0 ) {
+			fprintf (stderr, "Invalid actors number '%s'. "
+					"Choose a number greater than or equal to 1\n", argv[2]);
+			return TCL_ERROR;
+		}
+		actors_ = (unsigned int) atoi (argv[2]);
+		return TCL_OK;
+
+	} else if ( argc == 3 && strcmp (argv[1], "first-id") == 0 ) {
+		if ( atoi(argv[2]) <= 0 ) {
+			fprintf (stderr, "Invalid first Stat ID '%s'. "
+					"Choose a number greater than or equal to 0\n", argv[2]);
+			return TCL_ERROR;
+		}
+		firstId_ = (unsigned int) atoi (argv[2]);
+		return TCL_OK;
+
+	} else if ( argc == 4 && strcmp (argv[1], "add") == 0 ) {
+		// add a new element to the array of descriptors
+		descriptors_.resize (descriptors_.size() + 1);
+
+		// get a reference to the new element
+		Descriptor& buf = descriptors_.back();
+		
+		if ( strcmp (argv[2], "jain") == 0 ) {
+			buf.type_ = JAIN;
+		} else {
+			fprintf (stderr, "Invalid fairness index '%s'. "
+					"Choose 'jain'\n", argv[2]);
+			return TCL_ERROR;
+		}
+
+		if ( atof (argv[3]) <= 0 ) {
+			fprintf (stderr, "Invalid sampling period '%s'. "
+					"Choose a positive number of milliseconds.\n", argv[3]);
+			return TCL_ERROR;
+		}
+		buf.period_ = 1e-3 * atof (argv[3]);
+
+		if ( actors_ == 0 ) {
+			fprintf (stderr, "The number of actors must be initialized "
+					"befor you add fairness measures\n");
+			return TCL_ERROR;
+		}
+		buf.measures_.resize (actors_);
+
+		timer_.add (buf.period_, descriptors_.size() - 1);
+
+		return TCL_OK;
+	}
+	return TCL_ERROR;
+}
+
+void
+FairnessEstimator::put (double sample, unsigned int actor)
+{
+	// ignore actors which lie outside the specified range
+	if ( actor > ( actors_ - 1 ) ) return;
+
+	for ( unsigned int i = 0 ; i < descriptors_.size() ; i++ )
+		descriptors_[i].measures_[actor] += sample;
+}
+
+void
+FairnessEstimator::handle (unsigned int ndx)
+{
+	// current descriptor
+	Descriptor& current = descriptors_[ndx];
+
+	// compute the fairness index for the expired descriptor
+	if ( current.type_ == JAIN ) {
+
+		//
+		// we compute the Jain's fairness index, which is equal to the
+		// square of the measures' sum divided by the sum of square of the
+		// measures times the number of measures
+		//
+		// the index range is thus [0, 1]
+		//
+
+		double numerator = 0.0;
+		double denominator = 0.0;
+		for ( unsigned int i = 0 ; i < actors_ ; i++ ) {
+			double& x = current.measures_[i];
+			numerator += x;
+			denominator += x * x;
+			x = 0.0;            // remove each measure after use
+		}
+		denominator *= actors_;
+		numerator *= numerator;
+
+		// if the denominator is zero, then we do not insert any sample
+		if ( denominator > 0 )
+			Stat::put ("fairness", firstId_ + ndx, numerator/denominator);
+	}
+
+	// restart the timer
+	timer_.add (current.period_, ndx);
+}
diff --git a/ns-2.35/tools/fairness.h b/ns-2.35/tools/fairness.h
new file mode 100644
index 0000000..ba5b16c
--- /dev/null
+++ b/ns-2.35/tools/fairness.h
@@ -0,0 +1,80 @@
+/**
+   project: measure
+   filename: fairness.h
+   author: C. Cicconetti <c.cicconetti@iet.unipi.it>
+   year: 2006
+   affiliation:
+      Dipartimento di Ingegneria dell'Informazione
+      University of Pisa, Italy
+   description:
+      Fairness measures collection module
+*/
+
+#ifndef ns_fairness_h
+#define ns_fairness_h
+
+#include <vector>
+
+#include <object.h>
+
+#include <t_timers.h>
+
+//! Estimate fairness.
+/*!
+  Fairness is estimated via a set of timers, which can be set to expire
+  at periodical interval with different periods. Each interval produces
+  exactly one fairness measure, which is identified via an unsigned int.
+  Identifiers are forced to be contiguous (since we use an array as the
+  data structure to store them).
+
+  The set of intervals is configured via Tcl.
+
+  Fairness is computed according to Jain's fairness index.
+  */
+class FairnessEstimator : public TclObject {
+	//! Different fairness indexes.
+	enum Type { JAIN };
+
+	//! Fairness descriptor.
+	struct Descriptor {
+		//! Array of measures, resized to actors_.
+		std::vector<double> measures_;
+		//! Sampling period, in seconds.
+		double period_;
+		//! Fairness index type.
+		Type type_;
+	};
+	
+	//! Timer to sample fairness.
+	/*!
+	  This timer is used to both send samples to Stat and reset the
+	  collected measures.
+	  */
+	TMultiTimer<FairnessEstimator, unsigned int> timer_;
+
+	//! Number of entities which produce samples. Configured via Tcl.
+	unsigned int actors_;
+
+	//! First numerical identifier for the Stat class. Configured via Tcl.
+	unsigned int firstId_;
+
+	//! Array of descriptors. Each element is added via a Tcl command.
+	std::vector<Descriptor> descriptors_;
+
+public:
+	//! Create an empty object, which has to be initialized via Tcl.
+	FairnessEstimator ();
+	//! Do nothing.
+	virtual ~FairnessEstimator () { }
+	
+	//! Tcl interface.
+	virtual int command (int argc, const char*const* argv);
+
+	//! Add a sample for a given actor (indexed from 0 to actors_ - 1).
+	virtual void put (double sample, unsigned int actor);
+
+	//! Handle timer expires.
+	void handle (unsigned int ndx);
+};
+
+#endif // ns_fairness_h
diff --git a/ns-2.35/tools/ranvar.cc b/ns-2.35/tools/ranvar.cc
index beeda29..2c1ce89 100644
--- a/ns-2.35/tools/ranvar.cc
+++ b/ns-2.35/tools/ranvar.cc
@@ -449,7 +449,8 @@ double WeibullRandomVariable::avg(void)
 
 double WeibullRandomVariable::value()
 {
-        return(rng_->rweibull(scale_, shape_));
+	//return(rng_->rweibull(scale_, shape_));
+        return(rng_->rweibull(shape_,scale_));
 }
                                                                                
 /*
diff --git a/ns-2.35/tools/rng.cc b/ns-2.35/tools/rng.cc
index d394008..0748cfc 100644
--- a/ns-2.35/tools/rng.cc
+++ b/ns-2.35/tools/rng.cc
@@ -70,6 +70,10 @@ static const char rcsid[] =
 #endif /* !OLD_RNG */
 #include "rng.h"
 
+#ifdef MEASURE_MODULE
+#include "simulator.h"
+#endif // MEASURE_MODULE
+
 #ifdef OLD_RNG
 /*
  * RNGImplementation
@@ -260,7 +264,9 @@ RNG::command(int argc, const char*const* argv)
 		}
 #ifndef OLD_RNG
 		if (strcmp (argv[1], "next-substream") == 0) {
+			#ifndef MEASURE_MODULE
 			reset_next_substream();
+			#endif // MEASURE_MODULE
 			return (TCL_OK);
 		}
 		if (strcmp (argv[1], "all-seeds") == 0) {
@@ -803,6 +809,10 @@ void RNG::init()
 	} 
 	MatVecModM (A1p127, next_seed_, next_seed_, m1); 
 	MatVecModM (A2p127, &next_seed_[3], &next_seed_[3], m2); 
+	#ifdef MEASURE_MODULE
+	for ( unsigned int i = 0 ; i < Simulator::run() ; i++ )
+		reset_next_substream ();
+	#endif // MEASURE_MODULE
 }
 
 void RNG::set_seed (long seed) 
diff --git a/ns-2.35/tools/timestamper.cc b/ns-2.35/tools/timestamper.cc
new file mode 100644
index 0000000..4cf3f2c
--- /dev/null
+++ b/ns-2.35/tools/timestamper.cc
@@ -0,0 +1,69 @@
+/* 
+ *  Copyright (C) 2006 Dip. Ing. dell'Informazione, University of Pisa, Italy
+ *  http://info.iet.unipi.it/~cng/ns2measure/ns2measure.html
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA, USA
+ */
+
+/* Timestamper connector
+   This code has been developed within the EuQoS project of the EU IST 6th Framework Programme. 
+   The "timestamper" connector sits at the **head** of a link, (at least, provided nothing else is 
+   attached to the head of that link afterwards), and adds a timestamp to packets already marked by
+   an end-to-end tagger only (also see e2e{t,m}.{cc,h} files). If packets have NOT been marked by an 
+   end-to-end tagger, it simply does nothing.
+
+   Giovanni Stea (g.stea@iet.unipi.it), University of Pisa, Italy, June 2005. 
+*/
+
+
+#ifndef ns_timestamper_h
+#define ns_timestamper_h
+
+#include <connector.h>
+#include <packet.h>
+
+class timestamper : public Connector {
+	
+protected:
+	virtual void recv(Packet *, Handler *);
+};
+
+
+void timestamper::recv(Packet *p, Handler *)
+{
+	hdr_cmn *ch=hdr_cmn::access(p);
+	int howmany=ch->e2e_timestamp_no();
+
+	if (howmany>0 && howmany<TSTAMP_NO)
+	// only packets which have ALREADY been timestamped by a sending agent should be considered
+
+	{
+		ch->e2e_timestamp(howmany)=Scheduler::instance().clock();
+		ch->e2e_timestamp_no()++;
+	}
+	target_->recv(p);
+}
+
+
+static class timestamperClass : public TclClass {
+public:
+	timestamperClass() : TclClass ("timestamper") {}
+	TclObject* create(int,const char*const*) {
+		return (new timestamper());
+	}
+}class_timestamper;
+
+
+#endif
diff --git a/ns-2.35/voip/voip_aggregate.cc b/ns-2.35/voip/voip_aggregate.cc
new file mode 100644
index 0000000..11dbd86
--- /dev/null
+++ b/ns-2.35/voip/voip_aggregate.cc
@@ -0,0 +1,101 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#include <voip_aggregate.h>
+#include <voip_frame.h>
+#include <voip_header.h>
+#include <math.h>
+#include <stdio.h>
+
+static class VoipAggregateClass : public TclClass {
+public:
+   VoipAggregateClass() : TclClass("Application/VoipAggregate") {}
+   TclObject* create(int, const char*const*) {
+      return (new VoipAggregate);
+   }
+} class_voip_aggregate;
+
+VoipAggregate::VoipAggregate ()
+{
+        size_        = 0;
+        nframes_     = 0;
+        initialized_ = false;
+        debug_       = false;
+        payload_     = 0;
+        header_      = 0;
+        pending_     = 0;
+        pendingSize_ = 0;
+
+        agent_       = 0;       // base class member
+}
+
+int
+VoipAggregate::command (int argc, const char*const* argv)
+{
+        if ( argc == 2  && strcmp (argv[1], "debug") == 0 ) {
+                debug_ = true;
+                return TCL_OK;
+
+        } else if ( argc == 2  && strcmp (argv[1], "nodebug") == 0 ) {
+                debug_ = false;
+                return TCL_OK;
+
+        } else if ( argc >= 3 && strcmp (argv[1], "size") == 0 ) {
+                size_ = atoi (argv[2]);
+                return TCL_OK;
+
+        } else if ( argc == 3  && strcmp (argv[1], "header") == 0 ) {
+                header_ = (VoipHeader*) TclObject::lookup (argv[2]);
+                return TCL_OK;
+
+        } else if ( argc >= 3 && strcmp (argv[1], "nframes") == 0 ) {
+                nframes_ = atoi (argv[2]);
+                if ( nframes_ == 0 ) {
+                        fprintf (stderr, "Invalid number of aggregated frames '%d'\n",
+                                 nframes_);
+                        return TCL_ERROR;
+                }
+                return TCL_OK;
+        }
+        return Application::command (argc, argv);
+}
+
+void
+VoipAggregate::recv (VoipFrame& frame)
+{
+        if ( debug_ ) fprintf (stderr,
+                "%.9f frame received %d,%d (total %d) timestamp %f\n",
+                        NOW, frame.talkspurt_, frame.frame_, frame.nframes_, frame.timestamp_);
+
+        // Update the number of pending frames.
+        ++pending_;
+
+        // If this is the first frame of the payload, create a new payload.
+        if ( pending_ == 1 ) payload_ = new VoipPayload;
+
+        // Add the frame to the pending payload.
+        (*payload_) += frame;
+
+        // Update the current size of the payload.
+        pendingSize_ += frame.size_;
+
+        // If the payload is full, send the frame to the agent.
+        if ( pending_ == nframes_ || frame.frame_ == ( frame.nframes_ - 1 ) ) {
+
+                // Select the size to be advertised for the payload.
+                unsigned int size = ( size_ == 0 ) ? pendingSize_ : size_;
+
+                if ( header_ ) {
+                        header_->recvPayload( size, payload_ );
+                } else {
+                        // Send the message to the agent.
+                        agent_->sendmsg (size, (AppData*)payload_);
+                }
+
+                // Reset the status variables.
+                payload_ = 0;
+                pending_ = 0;
+                pendingSize_ = 0;
+        }
+}
diff --git a/ns-2.35/voip/voip_aggregate.h b/ns-2.35/voip/voip_aggregate.h
new file mode 100644
index 0000000..243eb00
--- /dev/null
+++ b/ns-2.35/voip/voip_aggregate.h
@@ -0,0 +1,69 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#ifndef __NS2_VOIP_AGGREGATE_H
+#define __NS2_VOIP_AGGREGATE_H
+
+class VoipHeader;
+
+#include <voip_frame.h>
+#include <app.h>
+#include <object.h>
+
+class VoipAggregate : public Application {
+public:
+	//! Create an empty VoIP aggregate object.
+	VoipAggregate ();
+
+	//! Return true if the object is ready to be started.
+	bool initialized () { return initialized_; }
+	
+	//! Tcl interface.
+	/*!
+	 * Tcl commands:
+	 * - $obj debug\n
+	 *   Enable debug to standard error.
+	 * - $obj nodebug\n
+	 *   Disable debug to standard error (default).
+	 * - $obj size $s \n
+	 *   Force the size of the aggregated payload to $s bytes.
+	 * - $obj nframes $n\n
+	 *   Aggregate (at most) $n frames into the same payload.
+	 */
+	virtual int command (int argc, const char*const* argv);
+
+	//! Receive a new frame from the encoder.
+	void recv (VoipFrame& frame);
+
+protected:
+        //! Payload size, in bytes.
+        /*!
+         * If size_ is equal to zero, then the payload size is set to the
+         * sum of the contained frames.
+         */
+        unsigned int size_;
+
+        //! Number of frames to aggregate into a payload.
+        unsigned int nframes_;
+
+        //! Number of pending frames;
+        unsigned int pending_;
+
+        //! Current payload size. Only used when size_ is equal to zero.
+        unsigned int pendingSize_;
+
+        //! Payload waiting to be sent.
+        VoipPayload* payload_;
+
+        //! Pointer to the VoIP Header Module
+        VoipHeader* header_;
+
+        //! True if debug is enabled.
+        bool debug_;
+
+        //! True if the object is ready to produce frames.
+        bool initialized_;
+};
+
+#endif // __NS2_VOIP_AGGREGATE_H
diff --git a/ns-2.35/voip/voip_bidirectional.cc b/ns-2.35/voip/voip_bidirectional.cc
new file mode 100644
index 0000000..00b6f08
--- /dev/null
+++ b/ns-2.35/voip/voip_bidirectional.cc
@@ -0,0 +1,365 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#include <voip_bidirectional.h>
+#include <voip_source.h>
+#include <ranvar.h>
+#include <stdio.h>
+#include <stat.h>
+
+static class VoipBidirectionalClass : public TclClass {
+public:
+   VoipBidirectionalClass() : TclClass("VoipBidirectional") {}
+   TclObject* create(int, const char*const*) {
+      return (new VoipBidirectional);
+   }
+} class_voip_bidirectional;
+
+VoipBidirectional::VoipBidirectional ()
+{
+	source_[0]   = 0;
+	source_[1]   = 0;
+	nsources_    = 0;
+	debug_       = false;
+	talkspurtsList_[0].clear();		
+	talkspurtsList_[1].clear();		
+}
+
+int
+VoipBidirectional::command (int argc, const char*const* argv)
+{
+	if ( argc == 2  && strcmp (argv[1], "debug") == 0 ) {
+		debug_ = true;
+		return TCL_OK;
+
+	} else if ( argc == 2  && strcmp (argv[1], "nodebug") == 0 ) {
+		debug_ = false;
+		return TCL_OK;
+
+	} else if ( argc == 2 && strcmp (argv[1], "start") == 0 ) {
+		if ( ! initialized () ) {
+			fprintf (stderr, "VoIP bidirectional not initialized");
+			return TCL_ERROR;
+		} 
+		if ( nsources_ == 0 ) {
+			fprintf (stderr, "There's nothing to start\n");
+			return TCL_ERROR;
+		}
+		if ( source_[0] ) source_[0]->handle ();
+		if ( source_[1] ) source_[1]->handle ();
+		return TCL_OK;
+	} else if ( argc == 2 && strcmp (argv[1], "stop") == 0 ) {
+		if ( source_[0] ) source_[0]->stop ();
+		if ( source_[1] ) source_[1]->stop ();
+		return TCL_OK;
+
+	} else if ( argc == 3 && strcmp (argv[1], "source") == 0 ) {
+		if ( nsources_ == 2 ) {
+			fprintf (stderr, "You cannot bound more than TWO sources to this object\n");
+			return TCL_ERROR;
+		}
+		source_[nsources_] = (VoipSource*) TclObject::lookup (argv[2]);
+		++nsources_;
+		return TCL_OK;
+
+	}
+	return TCL_ERROR;
+}
+
+static class VoipBidirectionalItuP59Class : public TclClass {
+public:
+   VoipBidirectionalItuP59Class() : TclClass("VoipBidirectionalItuP59") {}
+   TclObject* create(int, const char*const*) {
+      return (new VoipBidirectionalItuP59);
+   }
+} class_voip_bidirectional_itu_p59;
+
+VoipBidirectionalItuP59::VoipBidirectionalItuP59 () :
+	//timer_ (this),
+	singleTalkA_   (1.004),
+	singleTalkB_   (1.004),
+	doubleTalk_    (0.228),
+	mutualSilence_ (0.508)
+{
+	// Nihil.
+}
+
+static class VoipBidirectionalModifiedBradyClass : public TclClass {
+public:
+	VoipBidirectionalModifiedBradyClass() : TclClass("VoipBidirectionalModifiedBrady") {}
+	TclObject* create(int, const char*const*) {
+		return (new VoipBidirectionalModifiedBrady);
+	}
+} class_voip_bidirectional_modified_brady;
+
+VoipBidirectionalModifiedBrady::VoipBidirectionalModifiedBrady ()
+{
+	// Fill transition rate matrix of zero
+	for (int i=0; i<N_STATES; i++ ) {
+		for(int j=0; j<N_STATES; j++) {
+			Q_[i][j] = 0.0;
+		}
+	}
+	// Set transition rates
+	Q_[0][3] = Q_[5][4] =  0.83305;
+	Q_[0][6] = Q_[5][7] =  5.48900;
+	Q_[2][0] = Q_[1][5] =  2.15720;
+	Q_[1][0] = Q_[2][5] =  2.32450;
+	Q_[6][0] = Q_[7][5] = 27.62000;
+	Q_[3][0] = Q_[4][5] =  2.22220;
+	Q_[4][0] = Q_[3][5] =  1.04380;
+	Q_[0][1] = Q_[5][2] = Q_[6][1] = Q_[7][2] = 0.27853;
+
+	double sum;
+	for (int i=0; i<N_STATES; i++) {
+		sum = 0.0;
+		// Calculate
+		for (int j=0; j<N_STATES; j++)
+			sum += Q_[i][j];
+		// Create a Random Variable for each state
+		erv_[i] = new ExponentialRandomVariable ( 1/(sum) );
+		// Fill the Embedded Markov Chain (Jump Chain)
+		for (int j=0; j<N_STATES; j++) 
+			P_[i][j] = Q_[i][j]/sum;
+	}
+	// Start from the state in which A and B are silent and A spoke last
+	state_ = MUTUAL_SILENCE_A_LAST;
+
+	// Initialize the random variable used to determine state transitions
+	uniform_ = new UniformRandomVariable ( 0, 1 );
+
+	A_talkspurt_duration_ = 0.0;
+	B_talkspurt_duration_ = 0.0;
+	A_silence_duration_ = 0.0;
+	B_silence_duration_ = 0.0;
+}
+
+VoipBidirectionalModifiedBrady::State
+VoipBidirectionalModifiedBrady::nextState ( double rn ) {
+	
+	double sum = 0;
+	State newState = TALK_A;
+
+	for (int j=0; j<N_STATES; j++) {
+		sum += P_[state_][j];
+		if ( rn <= sum ) {
+			newState = (State) j;
+			break;
+		}
+	}
+
+	return newState;
+}
+
+void 
+VoipBidirectionalModifiedBrady::next (VoipSource* source, double& talk, double& silence) 
+{
+	int sourceNum;
+	if ( source == source_[0] ) 
+		sourceNum = 0;
+	else if ( source == source_[1] )
+		sourceNum = 1;
+	else {
+		fprintf ( stderr, "%.9f VoipBidirectional::next() Wrong source!\n", NOW);
+		abort();
+	}
+
+	// If the list of talkspurts for this source is empty, update it
+	if ( talkspurtsList_[sourceNum].empty() ) 
+		updateTalkspurtsList();
+
+	// Now at least one pair is present in the list, 
+	// then returns its values and pop it
+	std::pair< double, double >& tmp = talkspurtsList_[sourceNum].front();
+	talk = tmp.first;
+	silence = tmp.second;
+	if ( debug_ )
+		fprintf ( stderr, "%.9f VoipBidirectional::next() " 
+				  "source=%u, talk=%f, silence=%f!\n", 
+				  NOW, sourceNum, talk, silence);
+	talkspurtsList_[sourceNum].pop_front();
+}
+
+void 
+VoipBidirectionalModifiedBrady::updateTalkspurtsList() 
+{
+	// Exit if not initialized	
+	if ( ! initialized () ) {
+		fprintf (stderr, "VoIP bidirectional not initialized");
+		abort ();
+	}
+
+	if ( debug_ ) 
+		fprintf ( stderr, "%.9f updateTalkspurtList()\n", NOW );
+
+	// true if party A has at least a <talk,silence> pair
+	bool flag_A = false;
+	// true if party B has at least a <talk,silence> pair
+	bool flag_B = false;
+
+	do {
+		// Get duration of current status
+		double state_duration = erv_[state_]->value();
+		// Calculate the next state using Jump Matrix
+		State next_state = nextState( uniform_->value() );
+
+		switch ( state_ ) {
+			// Modified Brady model's state 1
+			case TALK_A:
+				// If A begin a talkspurt then it must be 
+				// long at least 15ms
+				if ( next_state == MUTUAL_SILENCE_A_LAST )
+					state_duration += 0.015;
+				break;
+			// Modified Brady model's state 6
+			case TALK_B:
+				// If B begin a talkspurt then it must be
+				// long at least 15ms
+				if ( next_state == MUTUAL_SILENCE_B_LAST ) 
+					state_duration += 0.015;
+				break;
+			// Modified Brady model's state 7
+			case SHORT_SILENCE_A_TALKS:
+			// Modified Brady model's state 8
+			case SHORT_SILENCE_B_TALKS:
+				break;
+			// Modified Brady model's state 4
+			case MUTUAL_SILENCE_A_LAST:
+			// Modified Brady model's state 5
+			case MUTUAL_SILENCE_B_LAST:
+				// Mutual silence duration is at least 200ms
+				state_duration += 0.2;
+				break;
+			// Modified Brady model's state 2
+			case DOUBLE_TALK_A_INTERRUPTED:
+				// If B begin a talkspurt (interrupting A) then
+				// it must be long at least 15ms
+				if ( next_state == TALK_A ) 
+					state_duration += 0.015;
+				break;
+			// Modified Brady model's state 3
+			case DOUBLE_TALK_B_INTERRUPTED:
+				// If A begin a talkspurt (interrupting A) then
+				// it must be long at least 15ms
+				if ( next_state == TALK_B ) 
+					state_duration += 0.015;
+				break;
+			default:
+			       	fprintf ( stderr, "VoipBidirectional: cannot be here!\n" );
+				abort();
+		}
+
+		if ( debug_ ) fprintf (stderr, "%.9f new voip-bidirectional state (%s), duration %f\n",
+				NOW, 
+				(state_ == TALK_A)? "A talk":
+				(state_ == TALK_B)? "B talk":
+				(state_ == MUTUAL_SILENCE_A_LAST)? "Mutual silence, A spoke last":
+				(state_ == MUTUAL_SILENCE_B_LAST)? "Mutual silence, B spoke last":
+				(state_ == SHORT_SILENCE_A_TALKS)? "Short silence while A talks":
+				(state_ == SHORT_SILENCE_B_TALKS)? "Short silence while B talks":
+				(state_ == DOUBLE_TALK_A_INTERRUPTED)? "Double talk, B interrupt A":
+				/*(state_ == DOUBLE_TALK_B_INTERRUPTED)?*/ "Double talk, A interrupt B",
+				state_duration);
+
+		// Construct a lists of talkspurts for A and B 
+		// and collect some statistics useful for debug (if enabled)
+		if ( state_ == TALK_A || 			// 1
+		     state_ == DOUBLE_TALK_A_INTERRUPTED || 	// 2
+		     state_ == DOUBLE_TALK_B_INTERRUPTED) {	// 3
+			// Party A is speaking
+			if ( A_silence_duration_ > 0.0 ) {
+				// End of a silence period (for A) detected
+				// Add a new <talkspurt,silence> pair for A to the list
+				if ( debug_)
+					fprintf( stderr, "%.9f New <Talkspurt,Silence>="
+							 "<%.9f,%.9f> pair for A\n",
+							 NOW, A_talkspurt_duration_, 
+							 A_silence_duration_);
+				talkspurtsList_[0].push_back( make_pair( A_talkspurt_duration_, 
+									 A_silence_duration_ ) );
+				flag_A = true;
+				A_silence_duration_ = 0.0;
+				A_talkspurt_duration_ = 0.0;
+			}
+ 			A_talkspurt_duration_ += state_duration;
+		}
+		else {						// 4,5,6,7,8
+			// Party A is silent
+			A_silence_duration_ += state_duration;
+		}
+
+		if ( state_ == TALK_B || 			// 6
+		     state_ == DOUBLE_TALK_A_INTERRUPTED || 	// 2
+		     state_ == DOUBLE_TALK_B_INTERRUPTED) {	// 3
+			// Party B is speaking
+			if ( B_silence_duration_ > 0.0 ) {
+				// End of a silence period (for A) detected
+				// Add a new <talkspurt,silence> pair for B to the list
+				if ( debug_ )
+					fprintf( stderr, "%.9f New <Talkspurt,Silence>="
+					 		 "<%.9f,%.9f> pair for B\n",
+							 NOW, B_talkspurt_duration_, 
+							 B_silence_duration_);
+				// Do not add a pair to the second party list if only one 
+				// source is attached to the Bidirectional object.
+				if ( nsources_ == 2 ) 
+					talkspurtsList_[1].push_back( make_pair( B_talkspurt_duration_, 
+										 B_silence_duration_ ) );
+				flag_B = true;
+				B_silence_duration_ = 0.0;
+				B_talkspurt_duration_ = 0.0;
+			}
+			B_talkspurt_duration_ += state_duration;
+		}
+		else {						// 1,4,5,7,8
+			// Party B is silent
+			B_silence_duration_ += state_duration;
+		}
+
+	if ( debug_ ) 
+		Stat::put ( "voip_state_duration" , state_, state_duration );
+
+		// Evolve to the new state
+		state_ = next_state;
+
+	} while ( ! (flag_A && flag_B) );
+}
+
+/*
+void
+VoipBidirectional::handle ()
+{
+	if ( ! initialized () ) {
+		fprintf (stderr, "VoIP bidirectional not initialized");
+		abort ();
+	}
+
+	double talk;
+	double silence;
+
+	// If there is a bidirectional module bound to this object
+	// then get the next talkspurt and silence periods from it.
+	if ( bidirectional_ ) {
+		bidirectional_->next (this, talk, silence);
+
+	// Otherwise, draw the talkspurt and silence period duration randomly
+	// from the random variables depending on the source model.
+	} else {
+		talk = talk_->value();
+		silence = silence_->value();
+	}
+
+	if ( debug_ ) fprintf (stderr, "%.9f new talkspurt %f, %f (ID %d)\n",
+		NOW, talk, silence, count_);
+
+	// Tell the encoder that a new talkspurt is to be generated.
+	encoder_->talkspurt (count_, talk);
+
+	// Update the talkspurt counter.
+	++count_;
+
+	// Reschedule this function to be called after the silence period.
+	timer_.start (talk + silence);
+}
+*/
diff --git a/ns-2.35/voip/voip_bidirectional.h b/ns-2.35/voip/voip_bidirectional.h
new file mode 100644
index 0000000..7b55ba9
--- /dev/null
+++ b/ns-2.35/voip/voip_bidirectional.h
@@ -0,0 +1,173 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#ifndef __NS2_VOIP_BIDIRECTIONAL_H
+#define __NS2_VOIP_BIDIRECTIONAL_H
+
+#include <object.h>
+#include <t_timers.h>
+#include <ranvar.h>
+#include <list>
+
+class VoipSource;
+
+class VoipBidirectional : public TclObject {
+public:
+        //! Create an empty VoIP bidirectional module.
+        VoipBidirectional ();
+
+        //! Return true if the object is ready to be started.
+        bool initialized () { return ( nsources_ >= 1 ); } 
+
+        //! Tcl interface.
+        /*!
+         * Tcl commands:
+         * - $obj debug\n
+         *   Enable debug to standard error.
+         * - $obj nodebug\n
+         *   Disable debug to standard error (default).
+	 * - $obj source
+	 *   Link a new voip-source to $obj
+	 * - $obj start
+	 *   Start traffic generation
+	 * - $obj stop
+	 *   Stop traffic generation
+         */
+        virtual int command (int argc, const char*const* argv);
+
+        //! Generate a new talkspurt.
+        virtual void next (VoipSource* source, double& talk, double& silence)
+			  { abort(); }
+
+protected:
+        //! Pointers to the VoIP sources
+        VoipSource* source_[2];
+	//! Current number of sources. When initialized is equal to two.
+	unsigned int nsources_;
+	//! A list of <talkspurt,silence> pairs for each speaking party
+	std::list< std::pair<double, double> > talkspurtsList_[2];
+	//! True if debug is enabled.
+	bool debug_;
+};
+
+/*
+ *  Finite State Machine:
+ *
+ *   /-------------\        p1        /--------------\
+ *  |               | -------------> |                |
+ *  | Single Talk A |       p2       | Mutual silence |
+ *  |               | <------------- |                |
+ *   \-------------/                  \--------------/
+ *     / \     |                        / \      |
+ *      |      |                         |       |
+ *      | 1-p3 | 1-p1                    | 1-p4  | 1-p2
+ *      |      |                         |       |
+ *      |     \ /                        |      \ /
+ *   /-------------\        p3        /--------------\
+ *  |               | -------------> |                |
+ *  | Double Talk   |       p4       | Single Talk B  |
+ *  |               | <------------- |                |
+ *   \-------------/                  \--------------/
+ *
+ *
+ *  E[Single Talk]    = 1.004 s
+ *  E[Double Talk]    = 0.228 s
+ *  E[Mutual Silence] = 0.508 s
+ * 
+ */
+class VoipBidirectionalItuP59 : public VoipBidirectional {
+	enum State { TALK_A, TALK_B, DOUBLE_TALK, MUTUAL_SILENCE };
+
+public:
+	//! Create a default bi-directional source according to ITU-T P.59.
+	VoipBidirectionalItuP59();
+
+	//! Tcl interface.
+	//virtual int command (int argc, const char*const* argv);
+
+	//! Generate a new talkspurt.
+	//virtual void next (VoipSource* source, double& talk, double& silence) {}
+
+protected:
+	//! Timer to schedule talkspurts.
+	//TTimer<VoipBidirectionalItuP59> timer_;
+	//! Random variable for single talk user A.
+	ExponentialRandomVariable singleTalkA_;
+	//! Random variable for single talk user B.
+	ExponentialRandomVariable singleTalkB_;
+	//! Random variable for double talk.
+	ExponentialRandomVariable doubleTalk_;
+	//! Random variable for mutual silence.
+	ExponentialRandomVariable mutualSilence_;
+	
+	//! Current state.
+	State state_;
+
+	//! TODO
+
+};
+
+#define N_STATES 8
+class VoipBidirectionalModifiedBrady : public VoipBidirectional {
+	enum State { TALK_A, 
+		     DOUBLE_TALK_A_INTERRUPTED,
+		     DOUBLE_TALK_B_INTERRUPTED,
+		     MUTUAL_SILENCE_A_LAST,
+		     MUTUAL_SILENCE_B_LAST,
+		     TALK_B,
+		     SHORT_SILENCE_A_TALKS,
+		     SHORT_SILENCE_B_TALKS };
+
+	//! Return the next state of the chain
+	State nextState ( double rn );
+
+public:
+	VoipBidirectionalModifiedBrady ();
+
+	~VoipBidirectionalModifiedBrady () {
+		for (unsigned int i=0; i<N_STATES; i++ ) 
+			delete erv_[i];
+		delete uniform_;
+	}
+	
+	/*!
+	 * Generate a list of talkspurt,silence pairs
+	 * for each speaking party
+	 */
+	void updateTalkspurtsList();
+
+	//! Return the durations of next talkspurt and silence periods
+        virtual void next (VoipSource* source, double& talk, double& silence);
+
+protected:
+	//! Transition rate matrix
+	double Q_[N_STATES][N_STATES];
+	        
+	//! A random variable for each state
+	ExponentialRandomVariable* erv_[N_STATES];
+
+	//! Random variable for state transitions
+	UniformRandomVariable* uniform_;
+
+	//! Embedded Markov Chain (Jump Chain)
+	double P_[N_STATES][N_STATES];
+
+	//! Current state
+	State state_;
+
+	// Talkspurt duration for source A 
+	double A_talkspurt_duration_;
+
+	// Talkspurt duration for source B
+	double B_talkspurt_duration_;
+
+	// Silence duration for source A 
+	double A_silence_duration_;
+
+	// Silence duration for source B
+	double B_silence_duration_;
+	
+};
+
+#endif // __NS2_VOIP_BIDIRECTIONAL_H
diff --git a/ns-2.35/voip/voip_decoder.cc b/ns-2.35/voip/voip_decoder.cc
new file mode 100644
index 0000000..7f13b0d
--- /dev/null
+++ b/ns-2.35/voip/voip_decoder.cc
@@ -0,0 +1,263 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#include <voip_decoder.h>
+#include <stat.h>
+#include <math.h>
+#include <stdio.h>
+
+static class VoipDecoderClass : public TclClass {
+public:
+        VoipDecoderClass() : TclClass("Application/VoipDecoder") { }
+        TclObject* create(int, const char*const*) {
+                return (new VoipDecoder);
+        }
+} class_voip_decoder;
+
+VoipDecoder::VoipDecoder () :
+	functor_ (this, &VoipDecoder::collectEnd)
+{
+        debug_       = false;
+        agent_       = 0;
+        id_          = -1;
+        cellId_      = 0;
+        peerId_      = -1;
+
+        // E-Model parameter for GSM AMR 12.2 Kb/s codec.
+        emodel_Ie_ = 5;
+        emodel_Bpl_ = 10;
+        emodel_A_ = 5;
+        emodel_Ro_ = 93.2;
+        mosThreshold_ = 3.0;
+        cellOutageMosThreshold_ = 0.10;
+	cellOutageLossThreshold_ = 0.02;
+
+        firstFrame_ = true;
+        currentFrame_ = 0;
+        currentTalk_ = 0;
+        currentTalkSize_ = 0;
+        delaySum_ = 0;
+        delayNum_ = 0;
+
+	nextDecoder_ = 0;
+
+        Stat::addPostProcessMetric(&functor_);
+}
+
+int
+VoipDecoder::command (int argc, const char*const* argv)
+{
+        if ( argc == 2  && strcmp (argv[1], "debug") == 0 ) {
+                debug_ = true;
+                return TCL_OK;
+
+        } else if ( argc == 2  && strcmp (argv[1], "nodebug") == 0 ) {
+                debug_ = false;
+                return TCL_OK;
+
+	} else if ( argc == 3  && strcmp (argv[1], "next-decoder") == 0 ) {
+		nextDecoder_ = (VoipDecoder*) TclObject::lookup (argv[2]);
+		return TCL_OK;
+
+
+	} else if ( argc == 3 && strcmp ( argv[1], "mos-threshold" ) == 0 ) {
+		mosThreshold_ = atof(argv[2]);
+		if (mosThreshold_ < 0) {
+			fprintf (stderr, "E-Model: Invalid MOS threshold '%f'", 
+					mosThreshold_);
+			return TCL_ERROR;
+		}
+		return TCL_OK;
+
+		} else if ( argc == 3 && strcmp ( argv[1], "cell-mos-threshold" ) == 0 ) {
+			cellOutageMosThreshold_ = atof(argv[2]);
+			if (cellOutageMosThreshold_ < 0 || cellOutageMosThreshold_ > 1.0) {
+				fprintf (stderr, "E-Model: Invalid Cell Outage MOS threshold '%f'", 
+						cellOutageMosThreshold_);
+				return TCL_ERROR;
+			}
+			return TCL_OK;
+	
+	} else if ( argc == 3 && strcmp ( argv[1], "cell-loss-threshold" ) == 0 ) {
+		cellOutageLossThreshold_ = atof(argv[2]);
+		if ( cellOutageLossThreshold_ < 0 || cellOutageLossThreshold_ > 1.0) {
+			fprintf (stderr, "E-Model: Invalid Cell Outage Loss threshold '%f'", 
+					cellOutageLossThreshold_);
+			return TCL_ERROR;
+
+		}
+		return TCL_OK;
+
+        } else if ( argc == 3 && strcmp (argv[1], "id") == 0 ) {
+                id_ = atoi(argv[2]);
+                if (id_ < 0) {
+                        fprintf (stderr, "Invalid id '%d'\n", id_);
+			return TCL_ERROR;
+
+                }
+                return TCL_OK;
+
+        } else if ( argc == 3 && strcmp (argv[1], "cell-id") == 0 ) {
+                cellId_ = atoi(argv[2]);
+                if (cellId_ < 0) {
+                        fprintf (stderr, "Invalid cell id '%d'\n", cellId_);
+                        return TCL_ERROR;
+                }
+                return TCL_OK;
+
+        } else if ( argc == 3 && strcmp (argv[1], "peer-id") == 0 ) {
+                peerId_ = atoi(argv[2]);
+                if (peerId_ < 0) {
+                        fprintf (stderr, "Invalid peer id '%d'\n", peerId_);
+                        return TCL_ERROR;
+                }
+                return TCL_OK;
+
+        } else if ( argc == 4 && strcmp ( argv[1], "emodel" ) == 0 ) {
+                if ( strcmp ( argv[2], "Ie" ) == 0 ) {
+                                emodel_Ie_ = atof(argv[3]);
+                                if (emodel_Ie_ < 0) {
+                                                fprintf (stderr, "E-Model: Invalid Ie '%f'", emodel_Ie_);
+                                                return TCL_ERROR;
+                                }
+
+                } else if ( strcmp ( argv[2], "Bpl" ) == 0 ) {
+                                emodel_Bpl_ = atof(argv[3]);
+                                if (emodel_Bpl_ < 0) {
+                                                fprintf (stderr, "E-Model: Invalid Bpl '%f'", emodel_Bpl_);
+                                                return TCL_ERROR;
+                                }
+
+                } else if ( strcmp ( argv[2], "A" ) == 0 ) {
+                                emodel_A_ = atof(argv[3]);
+                                if (emodel_A_ < 0) {
+                                                fprintf (stderr, "E-Model: Invalid A '%f'", emodel_A_);
+                                                return TCL_ERROR;
+                                }
+
+                } else if ( strcmp ( argv[2], "Ro" ) == 0 ) {
+                                emodel_Ro_ = atof(argv[3]);
+                                if (emodel_Ro_ < 0) {
+                                                fprintf (stderr, "E-Model: Invalid Ro '%f'", emodel_Ro_);
+                                                return TCL_ERROR;
+                                }
+                }
+                        return TCL_OK;
+        }
+
+        // For more detail, please refer to ITU-T Recommendation G.113
+        else if ( argc == 3 && strcmp ( argv[1], "emodel" ) == 0 ) {
+                if ( strcmp ( argv[2], "G.711" ) == 0 ) {
+                        emodel_Ie_ = 0;
+                        emodel_Bpl_ = 4.3;
+                        return TCL_OK;
+
+                } else if ( strcmp ( argv[2], "G.729A" ) == 0 ) {
+                        emodel_Ie_ = 11.0;
+                        emodel_Bpl_ = 19.0;
+                        return TCL_OK;
+
+                } else if ( strcmp ( argv[2], "G.723.1" ) == 0 ) {
+                        emodel_Ie_ = 15.0;
+                        emodel_Bpl_ = 16.1;
+                        return TCL_OK;
+
+                } else if ( strcmp ( argv[2], "GSM.EFR" ) == 0 ) {
+                        emodel_Ie_ = 5.0;
+                        emodel_Bpl_ = 10.0;
+                        return TCL_OK;
+
+                } else if ( strcmp ( argv[2], "GSM.AMR" ) == 0 ) {
+                        // GSM_AMR uses the same value of GSM_EFR
+                        emodel_Ie_ = 5.0;
+                        emodel_Bpl_ = 10.0;
+                        return TCL_OK;
+
+                } else {
+                        fprintf(stderr, "VoipDecoder - Unsupported Codec\n");
+                        return TCL_ERROR;
+                }
+        }
+
+        return Application::command (argc, argv);
+}
+
+void
+VoipDecoder::process_data (int size, AppData* data)
+{
+	VoipPayload* payload = (VoipPayload*) data;
+
+        while ( payload->nframes() > 0 ) {
+                VoipFrame frame(--(*payload));
+		if ( nextDecoder_ != 0 ) nextDecoder_->collectFrame(frame);
+                collectFrame (frame);
+                if ( debug_ ) {
+                        fprintf (stderr, "%.9f payload received", NOW);
+                        fprintf (stderr, " frame %d,%d (total %d) timestamp %f",
+                        frame.talkspurt_, frame.frame_,
+                                frame.nframes_, frame.timestamp_);
+                        fprintf (stderr, "\n");
+                }
+        }
+}
+
+void
+VoipDecoder::collectFrame (VoipFrame& frame)
+{
+	if ( currentTalk_ > frame.talkspurt_ ) return;
+
+        bool newTalkspurt = false;
+        if ( currentTalk_ < frame.talkspurt_ || firstFrame_ ) {
+                collectTalkspurt (currentTalkSize_);
+                currentTalk_     = frame.talkspurt_;
+                currentFrame_    = frame.frame_;
+                currentTalkSize_ = frame.nframes_;
+                delayNum_        = 0;
+                delaySum_        = 0;
+                newTalkspurt     = true;
+        }
+
+        const double delay = NOW - frame.timestamp_;
+        if ( frame.frame_ >= ( currentFrame_ + 1 ) || newTalkspurt || firstFrame_ ) {
+                ++delayNum_;
+                delaySum_ += delay;
+                firstFrame_ = false;
+        }
+        currentFrame_ = frame.frame_;
+}
+
+double
+VoipDecoder::eModel (double delay, double loss)
+{
+	double delayms = 1000 * delay;
+
+	// Compute the Id parameter
+	int u = ( (delayms - 177.3) > 0 ? 1: 0 );
+	double id = 0.0;
+	id = 0.024 * delayms + 0.11 * (delayms - 177.3) * u;
+
+	// Packet loss p in %
+	double p = loss * 100;
+	// Compute the Ie,eff parameter
+	double ie_eff = emodel_Ie_ + (95 - emodel_Ie_) * p / (p + emodel_Bpl_);
+
+	// Compute the R factor
+	double Rfactor = emodel_Ro_ - id - ie_eff + emodel_A_;
+
+	// Compute the MOS value
+	double mos = 0.0;
+
+	if (Rfactor < 0) {
+                mos = 1.0;
+	}
+	else if (Rfactor > 100) {
+                mos = 4.5;
+	}
+	else {
+                mos = 1 + 0.035 * Rfactor + 7 * pow(10, -6) * Rfactor * (Rfactor - 60) * (100 - Rfactor);
+	}
+	mos = ( mos < 1 ) ? 1 : mos;
+
+	return mos;
+}
diff --git a/ns-2.35/voip/voip_decoder.h b/ns-2.35/voip/voip_decoder.h
new file mode 100644
index 0000000..7675ad9
--- /dev/null
+++ b/ns-2.35/voip/voip_decoder.h
@@ -0,0 +1,131 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#ifndef __NS2_VOIP_DECODER_H
+#define __NS2_VOIP_DECODER_H
+
+#include <app.h>
+#include <object.h>
+#include <voip_frame.h>
+#include <tfunctor.h>
+
+class VoipDecoder : public Application {
+public:
+	//! Create an empty VoIP source.
+	VoipDecoder ();
+
+	//! Process incoming VoIP payloads.
+	virtual void process_data(int size, AppData* data);
+
+	//! Tcl interface.
+	int command (int argc, const char*const* argv);
+
+protected:
+	//! Collect statistics after playout buffering frame by frame.
+	virtual void collectFrame (VoipFrame& frame);
+	//! Collect statistics after playout buffering talkspurt by talkspurt.
+	virtual void collectTalkspurt (unsigned int nframes) { }
+	//! Collect statistics after playout buffering at the end of simulation.
+	virtual void collectEnd () { }
+
+	//! Compute the Mean Opinion Score (MOS).
+	virtual double eModel (double delay, double loss);
+
+	//! Create a call-back object to manage statistical data collection.
+	TSpecificFunctor<VoipDecoder> functor_;
+
+protected:
+	//! True if debug is enabled.
+	bool debug_;
+
+	//! Statistic Metric ID.
+	int id_;
+	//! Cell Id. The identifier of my cell. Set via Tcl.
+	int cellId_;
+	//! Peer Id. The identifier of my peer. Set via Tcl.
+	int peerId_;
+
+	// :TODO: commentare
+	unsigned int currentFrame_;
+	unsigned int currentTalk_;
+	unsigned int currentTalkSize_;
+	double delaySum_;
+	unsigned int delayNum_;
+	bool firstFrame_;
+
+	//! Transmission Rating Factor Ro Parameters
+	/** The term Ro expresses the basic signal-to-noise ratio 
+	* (received speech level relative to circuit and acoustic 
+	* noise).
+	*/
+	double emodel_Ro_;
+
+        //! Expectation Factor (Advantage Factor)
+
+        /** The factor is representing a "bonus", a tolerance given by
+         *  the users to some technologies or circumstances.
+         *  This value is given in units of impairments, so that it 
+         *  can be directly used in conjunction with other Impairmant 
+         *  Factors.
+         *  - No Unit (units of impairments)
+         *  - Typical range is [0,20].
+         *  <ul>
+         *   <li>  0 - Conventional fixed line PSTN </li>
+         *   <li>  5 - Local area wireless (cordless phone) </li>
+         *   <li> 10 - Wide area wireless (cell phone) </li>
+         *   <li> 20 - Satellite </li>
+         *  </ul>
+	 */
+	double emodel_A_;
+
+	//! Equipment Impairment Factor
+	/** Specific (modern) equipments used in the transmission 
+	*  path, such as ADPCM encoders, compression 
+	*  (G.728, GSM 6.x0) produce distortions causing a decrease 
+	*  of the perceived quality. They cannot be described with 
+	*  the Quantizing Distortion Unit, and have been estimated 
+	*  subjectively.
+	*  This value is given in units of impairments, so that it 
+	*  can be directly used in conjunction with other Impairmant 
+	*  Factors.
+	*  - No Unit (units of impairments)
+	*  - Typical range is [0,50].
+	*/
+	double emodel_Ie_;
+
+	//! Packet Loss Robustness Factor
+	/** Bpl is the robustness of a codec to random packet loss.
+	*/
+	double emodel_Bpl_;
+
+	//! MOS threshold.
+	/** If the MOS of a talkspurt is greater than or equal to this threshold,
+	 * then the perceived quality of that talkspurt is considered to be good.
+	 */
+	double mosThreshold_;
+
+	//! Outage MOS threshold.
+	/** If the ratio between the 'good' talkspurts, according to the MOS
+	 * threshold, and the total number of talkspurts is greater than or equal
+	 * to this threshold, then it is assumed that the user perceives an
+	 * overall good quality.
+	 */
+	double cellOutageMosThreshold_;
+
+	//! Outage Loss threshold.
+	/** If the percentage of loss packets is under
+	 *  this threshold, then it is assumed that the user perceives an
+	 * overall good quality.
+	 */
+	double cellOutageLossThreshold_;
+
+	//! Pointer to the next VoipDecoder
+	/** VoIP frames traverses a chain of decoder
+	 *  in order to collect more statistic types
+	 *  in a single simulation run.
+	 */ 
+	VoipDecoder* nextDecoder_;
+};
+
+#endif // __NS2_VOIP_DECODER_H
diff --git a/ns-2.35/voip/voip_decoder_80216m.cc b/ns-2.35/voip/voip_decoder_80216m.cc
new file mode 100644
index 0000000..1e561dd
--- /dev/null
+++ b/ns-2.35/voip/voip_decoder_80216m.cc
@@ -0,0 +1,78 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#include <voip_decoder_80216m.h>
+#include <stat.h>
+#include <math.h>
+#include <stdio.h>
+
+static class VoipDecoder80216mClass : public TclClass
+{
+        public:
+                VoipDecoder80216mClass() : TclClass ( "Application/VoipDecoder80216m" ) {}
+                TclObject* create ( int, const char*const* )
+                {
+                        return ( new VoipDecoder80216m );
+                }
+}
+class_voip_decoder_80216m;
+
+VoipDecoder80216m::VoipDecoder80216m ()
+{}
+
+int
+VoipDecoder80216m::command ( int argc, const char*const* argv )
+{
+        return VoipDecoder::command ( argc, argv );
+}
+
+void
+VoipDecoder80216m::collectFrame ( VoipFrame& frame )
+{
+	// If statistic collection is enabled 
+	// Count the number of received frames
+	if ( frame.statActive_ ) {
+		Stat::put("voip_frames_recv",id_,1);
+	}
+}
+
+void
+VoipDecoder80216m::collectEnd ()
+{
+	// calculate cell outage
+	
+	double sent = Stat::get("voip_frames_sent",id_);
+	double recv = Stat::get("voip_frames_recv",id_);
+	
+	if ( ! sent ) return;
+	double loss = (sent-recv)/sent;
+
+	// Is bidirectional enabled ?
+	if ( peerId_ != -1 ) {
+		// Only one speaking party collect statistics about conversation
+		if ( id_ < peerId_ ) return;
+		// If bidirectional is active then calculate cell outage
+		// based on conversations instead that on flows
+		double sent_peer = Stat::get("voip_frames_sent",peerId_);
+		double recv_peer = Stat::get("voip_frames_recv",peerId_);
+
+		if ( ! sent_peer ) return;
+		double loss_peer = (sent_peer-recv_peer)/sent_peer;
+
+		if ( ( loss > cellOutageLossThreshold_ ) || 
+		     ( loss_peer > cellOutageLossThreshold_ ) )  {
+			Stat::put("voip_cell_outage", cellId_ , 1);
+		} else {
+			Stat::put("voip_cell_outage", cellId_ , 0);
+		}
+
+	} else {
+		if ( loss > cellOutageLossThreshold_ ) {
+			Stat::put("voip_cell_outage", cellId_ , 1);
+		} else {
+			Stat::put("voip_cell_outage", cellId_ , 0);
+		}
+	}
+}
+
diff --git a/ns-2.35/voip/voip_decoder_80216m.h b/ns-2.35/voip/voip_decoder_80216m.h
new file mode 100644
index 0000000..317042c
--- /dev/null
+++ b/ns-2.35/voip/voip_decoder_80216m.h
@@ -0,0 +1,29 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#ifndef __NS2_VOIP_DECODER_80216M_H
+#define __NS2_VOIP_DECODER_80216M_H
+
+#include <voip_decoder.h>
+#include <map>
+#include <vector>
+
+class VoipDecoder80216m : public VoipDecoder {
+public:
+	//! Create an empty VoIP decoder.
+	VoipDecoder80216m ();
+
+	//! Tcl interface.
+	int command (int argc, const char*const* argv);
+
+protected:
+	//! Collect statistics after playout buffering frame by frame.
+	virtual void collectFrame (VoipFrame& frame);
+	//! Collect statistics after playout buffering talkspurt by talkspurt.
+	//void collectTalkspurt (unsigned int nframes);
+	//! Collect statistics after playout buffering at the end of simulation.
+	void collectEnd ();
+};
+
+#endif // __NS2_VOIP_DECODER_80216M_H
diff --git a/ns-2.35/voip/voip_decoder_atzori.cc b/ns-2.35/voip/voip_decoder_atzori.cc
new file mode 100644
index 0000000..77a240b
--- /dev/null
+++ b/ns-2.35/voip/voip_decoder_atzori.cc
@@ -0,0 +1,171 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#include <voip_decoder_atzori.h>
+#include <stat.h>
+#include <math.h>
+#include <stdio.h>
+
+static class VoipDecoderAtzoriClass : public TclClass
+{
+        public:
+                VoipDecoderAtzoriClass() : TclClass ( "Application/VoipDecoderAtzori" ) {}
+                TclObject* create ( int, const char*const* )
+                {
+                        return ( new VoipDecoderAtzori );
+                }
+}
+class_voip_decoder_atzori;
+
+VoipDecoderAtzori::VoipDecoderAtzori ()
+{
+	endLost_ = 0;
+	endRecv_ = 0;
+	endDelay_ = 0;
+	prevDelay_=0.0;
+}
+
+int
+VoipDecoderAtzori::command ( int argc, const char*const* argv )
+{
+        return VoipDecoder::command ( argc, argv );
+}
+
+void
+VoipDecoderAtzori::collectFrame ( VoipFrame& frame )
+{
+        // Access/add the current talkspurt data.
+        TalkData& talk = talkData_[frame.talkspurt_];
+
+        // If this is the first frame of this talkspurt, then update data.
+        if ( talk.nframes_ == 0 )
+        {
+		talk.statActive_ = Stat::active();
+                talk.nframes_ = frame.nframes_;
+                talk.delay_.resize ( talk.nframes_, -1.0 );
+        }
+
+        // Update the number of received frames.
+        if ( talk.delay_[frame.frame_] < 0 ) ++talk.received_;
+
+        // Add/update the delay sample for the current frame.
+        double delay = NOW - frame.timestamp_;
+        if ( talk.delay_[frame.frame_] < 0 || talk.delay_[frame.frame_] > delay )
+        {
+                talk.delay_[frame.frame_] = delay;
+        }
+
+        if ( talk.nframes_ == talk.received_ )
+        {
+                // If the last frame of this talkspurt has been added, then
+                // compute the measures for this talkspurt.
+                collectTalkspurt ( frame.talkspurt_ );
+
+                // Remove this talkspurt.
+                talkData_.erase ( frame.talkspurt_ );
+        }
+}
+
+void
+VoipDecoderAtzori::collectTalkspurt ( unsigned int nframes )
+{
+	  // Access the current talkspurt data.
+	  TalkData& talk = talkData_[nframes];
+
+	  if ( ! talk.statActive_ ) return;
+
+	  double talkPer =0.0;
+	  double talkReceived =0.0;
+	  
+	  for ( unsigned int i = 0 ; i < talk.nframes_ ; i++ ) 
+	  {
+			if ( talk.delay_[i] < 0 || talk.delay_[i] > prevDelay_ ) {
+				++endLost_;
+				++ talkPer;
+			}
+			else {
+			      endDelay_ += talk.delay_[i] + prevDelay_;
+			      ++endRecv_;
+			      ++ talkReceived;
+		      }
+	  }
+	  
+	  talkPer/=talk.nframes_;
+	  double talkMos = eModel ( prevDelay_, talkPer);
+	    
+	  Stat::put ("voip_playout_talkspurt_delay", id_, prevDelay_);
+	  Stat::put ("voip_playout_talkspurt_per", id_, talkPer );
+	  Stat::put ("voip_mos_distribution", id_, talkMos);
+	  Stat::put ("voip_satisfaction", id_,( talkMos >= mosThreshold_ ) ? 1.0 : 0);
+
+	  
+	  double bestMos  = -1.0;
+	  double bestDelay = 0.0;
+
+	  // Get the optimal value of the delay for this talkspurt.
+	  for ( unsigned int i = 0 ; i < talk.nframes_ ; i++ )
+	  {
+				 double per   = 0;
+				 double delay = talk.delay_[i];
+				 if ( delay < 0 ) continue;
+
+				 // Compute the packet loss with this delay.
+				 for ( unsigned int j = 0 ; j < talk.nframes_ ; j++ )
+				 {
+					 if ( talk.delay_[j] < 0 || talk.delay_[j] > delay ) {
+						 ++per;
+					 }
+				 }
+				 per /= talk.nframes_;
+
+				 double mos = eModel ( delay, per );
+
+				 if ( bestMos < 0 || mos > bestMos )
+				 {
+							bestMos = mos;	
+							bestDelay = delay;
+				 }
+	  }
+	  //storing best playout delay for next talkspurt
+	  prevDelay_=bestDelay;
+}
+
+void
+VoipDecoderAtzori::collectEnd ()
+{
+        unsigned int max = 0;
+        std::map<unsigned int, TalkData>::iterator it;
+        for ( it = talkData_.begin () ; it != talkData_.end () ; ++it )
+        {
+                if ( it == talkData_.begin() || it->first > max )
+                        max = it->first;
+        }
+        talkData_.erase ( max );
+        for ( it = talkData_.begin () ; it != talkData_.end () ; ++it )
+        {
+                collectTalkspurt ( it->first );
+        }
+
+		  // :TODO: add comment
+		  if ( peerId_ == -1 || id_ > peerId_ ) {
+			  if ( Stat::get ("voip_satisfaction", id_) >=
+					    cellOutageMosThreshold_ &&
+				    ( peerId_ == -1 || Stat::get ("voip_satisfaction", peerId_) >=
+					    cellOutageMosThreshold_ ) )
+				  Stat::put ("voip_cell_satisfaction", cellId_, 1.0);
+			  else
+				  Stat::put ("voip_cell_satisfaction", cellId_, 0);
+		  }
+
+	// Calculate MOS based on the entire conversation delay and loss
+	if ( endRecv_ != 0 ) {
+		endDelay_ /= endRecv_;
+		double endPer = ((double) endLost_) / (endLost_ + endRecv_ );
+		double endMos = eModel ( endDelay_ , endPer );
+		Stat::put("voip_mos_conversation", id_, endMos);
+	}
+        // Collect Gloabl metrics
+        // Call the base class collect End function.
+        VoipDecoder::collectEnd();
+}
diff --git a/ns-2.35/voip/voip_decoder_atzori.h b/ns-2.35/voip/voip_decoder_atzori.h
new file mode 100644
index 0000000..9757af9
--- /dev/null
+++ b/ns-2.35/voip/voip_decoder_atzori.h
@@ -0,0 +1,66 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#ifndef __NS2_VOIP_DECODER_ATZORI_H
+#define __NS2_VOIP_DECODER_ATZORI_H
+
+#include <voip_decoder.h>
+#include <map>
+#include <vector>
+
+class VoipDecoderAtzori : public VoipDecoder {
+public:
+    //! Create an empty VoIP decoder.
+    VoipDecoderAtzori ();
+
+    //! Tcl interface.
+    int command (int argc, const char*const* argv);
+
+protected:
+    //! Collect statistics after playout buffering frame by frame.
+    virtual void collectFrame (VoipFrame& frame);
+    //! Collect statistics after playout buffering talkspurt by talkspurt.
+    void collectTalkspurt (unsigned int nframes);
+    //! Collect statistics after playout buffering at the end of simulation.
+    void collectEnd ();
+
+protected:
+
+    /*
+     * Used for MOS calculation over the entire conversation
+     * rather than for each talkspurt.
+     */
+    //! Counter for lost packets
+    unsigned long endLost_;
+    //! Counter for received packets
+    unsigned long endRecv_;
+    //! per-conversation packet delay
+    double endDelay_;
+    //! previous bestDelay
+    double prevDelay_;
+
+    //! Talkspurt data structure.
+    struct TalkData {
+        //! Delay samples, in seconds.
+        std::vector<double> delay_;
+        //! Number of frames in this talkspurt.
+        unsigned int nframes_;
+        //! Number of frames received so far.
+        unsigned int received_;
+        //! Statistics collection flag
+        bool statActive_;
+
+        //! Create an empty talkspurt data structure.
+        TalkData () {
+            nframes_    = 0;
+            received_   = 0;
+            statActive_ = false;
+        }
+    };
+
+    //! One talkspurt data structure for each talkspurt ID.
+    std::map<unsigned int, TalkData> talkData_;
+};
+
+#endif // __NS2_VOIP_DECODER_ATZORI_H
diff --git a/ns-2.35/voip/voip_decoder_h323.cc b/ns-2.35/voip/voip_decoder_h323.cc
new file mode 100644
index 0000000..f2aafa1
--- /dev/null
+++ b/ns-2.35/voip/voip_decoder_h323.cc
@@ -0,0 +1,411 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#include <voip_decoder_h323.h>
+#include <stat.h>
+#include <math.h>
+#include <stdio.h>
+
+#define CODEC_PERIOD 0.020
+
+/**How much time must elapse with lower jitter before jitter
+   buffer size is reduced */
+#define DECREASE_JITTER_PERIOD 5000 // milliseconds
+
+/* Percentage of current jitter buffer size that constitutes a "genuinely" smaller
+jitter */
+#define LOWER_JITTER_MAX_PCNT   80
+
+/* Minimum number of packets that constitute a reliable sample for setting a lower
+jitter buffer target */
+#define DECREASE_JITTER_MIN_PACKETS 50
+
+static class VoipDecoderH323Class : public TclClass
+{
+        public:
+                VoipDecoderH323Class() : TclClass ( "Application/VoipDecoderH323" ) {}
+                TclObject* create ( int, const char*const* )
+                {
+                        return ( new VoipDecoderH323 );
+                }
+}
+class_voip_decoder_optimal;
+
+VoipDecoderH323::VoipDecoderH323 ()
+{
+	endLost_ = 0;
+	endRecv_ = 0;
+	endDelay_ = 0;
+	codecTime_=0.0;
+	// dejitter starts from prebuffering
+	prebuffering_=true;
+	
+	consecutiveEarlyPacketStartTime_ = 0;
+	jitterCalcPacketCount_ = 0;
+	jitterCalc_ = 0;
+	
+	minJitterTime_=0.001;
+	maxJitterTime_=0.020;
+	//! \todo - configure from tcl
+	doJitterReductionImmediately_=true;
+	
+	currentJitterTime_=minJitterTime_;
+	targetJitterTime_ = currentJitterTime_;
+}
+
+int
+VoipDecoderH323::command ( int argc, const char*const* argv )
+{
+	if ( argc == 3 && strcmp ( argv[1], "min-jitter" ) == 0 ) {
+		minJitterTime_ = atof(argv[2]);
+		return TCL_OK;
+	} else if ( argc == 3 && strcmp ( argv[1], "max-jitter" ) == 0 ) {
+		maxJitterTime_ = atof(argv[2]);
+		return TCL_OK;
+	}
+        return VoipDecoder::command ( argc, argv );
+}
+
+void
+VoipDecoderH323::collectFrame ( VoipFrame& frame )
+{
+  
+        // Access/add the current talkspurt data.
+        TalkData& talk = talkData_[frame.talkspurt_];
+	
+        // If this is the first frame of this talkspurt, then update data.
+        if ( talk.nframes_ == 0 )
+        {
+		talk.statActive_ = Stat::active();
+                talk.nframes_ = frame.nframes_;
+                talk.timestamp_.resize ( talk.nframes_, -1.0 );
+		talk.tick_.resize ( talk.nframes_, -1.0 );
+        }
+
+        // Update the number of received frames.
+        ++talk.received_;
+
+        // record timestamp and arrival time
+        talk.timestamp_[frame.frame_] = frame.timestamp_;
+	talk.tick_[frame.frame_] =NOW;
+        
+
+        if ( talk.nframes_ == talk.received_ )
+        {
+                // If the last frame of this talkspurt has been added, then
+                // compute the measures for this talkspurt.
+                collectTalkspurt ( frame.talkspurt_ );
+
+                // Remove this talkspurt.
+                talkData_.erase ( frame.talkspurt_ );
+        }
+}
+
+void
+VoipDecoderH323::collectTalkspurt ( unsigned int nframes )
+{
+	  // Access the current talkspurt data.
+	  TalkData& talk = talkData_[nframes];
+
+	  if ( ! talk.statActive_ ) return;
+
+	  double per =0.0;
+	  double delay=-1.0;
+	  // set the codec start of operation at first frame arrival
+	  // all actions that would have been performed while dejitter buffer
+	  // was empty are useless
+	  codecTime_=talk.tick_[0];
+	  for ( ; (codecTime_<=talk.tick_[talk.received_-1]); codecTime_+=CODEC_PERIOD )
+	  {	
+		
+		for (unsigned int i =0 ; i<talk.nframes_;++i)
+		{
+		  if (talk.tick_[i]<=codecTime_)  
+		  {
+		    talk.newest_=i;
+		  }  
+		  else break;
+		}
+		// buffer empty condition
+		if (talk.newest_<0 ) 
+		{
+		    prebuffering_=true;
+		    currentJitterTime_=targetJitterTime_;
+		    continue;
+		}
+		
+		double oldestTimestamp = talk.timestamp_[talk.oldest_];
+		double newestTimestamp = talk.timestamp_[talk.newest_];
+
+// 		 If there is an opportunity (due to silence in the buffer) to implement a desired 
+// 		reduction in the size of the jitter buffer, effect it 
+
+		if (targetJitterTime_ < currentJitterTime_ && (newestTimestamp - oldestTimestamp) < currentJitterTime_ ) 
+		{
+		    currentJitterTime_ = ( targetJitterTime_ > (newestTimestamp - oldestTimestamp)) ?
+                          targetJitterTime_ : (newestTimestamp - oldestTimestamp);
+		
+		}
+		
+		/* See if time for this packet, if our oldest frame is older than the
+		required age, then use it. */
+		
+		if (prebuffering_) 
+		{
+		  // Reset jitter baseline
+		  talk.lastWrite_=-1;
+		  
+		  // If oldest frame has not been in the buffer long enough, don't return anything yet
+		    if ((codecTime_ - talk.tick_[talk.oldest_])  < currentJitterTime_ / 2) 
+		    {
+		      // go ahead in codec "for" time sequence
+		      continue;
+		    }
+		    
+		    //else deactivate prebuffering
+		    prebuffering_=false;
+		}
+		
+		// Detatch oldest packet from the list, put into parking space
+	      
+		talk.currentWrite_ = talk.oldest_;
+		if (talk.oldest_ < talk.newest_)  talk.oldest_ ++;
+		
+		// Calculate the jitter contribution of this frame
+		// - don't count if start of a talk burst
+		if (talk.currentWrite_<=0) 
+		{
+		  talk.lastWrite_ = -1;  
+		}
+		
+		if (talk.lastWrite_ > -1) 
+		{
+		  double thisJitter = 0;
+		
+		  if (talk.timestamp_[talk.currentWrite_]  < talk.timestamp_[talk.lastWrite_] ) 
+		  {
+		    //Not too sure how to handle this situation...
+		    thisJitter = 0;
+		  }
+		  else if (talk.tick_[talk.currentWrite_]  < talk.tick_[talk.lastWrite_]) 
+		  {
+		    //Not too sure how to handle this situation either!
+		    thisJitter = 0;
+		  } else {  
+		      thisJitter = (talk.tick_[talk.currentWrite_] - talk.tick_[talk.lastWrite_] + 
+		      talk.timestamp_[talk.lastWrite_] - talk.timestamp_[talk.currentWrite_]);
+		  }
+		  
+		  if (thisJitter < 0) thisJitter *=(-1);
+		  thisJitter *=2; //currentJitterTime needs to be at least TWICE the maximum jitter
+
+		  if (thisJitter >  currentJitterTime_ * LOWER_JITTER_MAX_PCNT / 100) 
+		  {
+		    targetJitterTime_ = currentJitterTime_;
+	    
+		    consecutiveEarlyPacketStartTime_ = codecTime_;
+		    jitterCalcPacketCount_ = 0;
+		    jitterCalc_ = 0;
+		  } else {
+		    if ( thisJitter >  jitterCalc_ )
+			  jitterCalc_ = thisJitter;
+			  jitterCalcPacketCount_++;
+
+		      //If it's bigger than the target we're currently trying to set, adapt that target.
+		      //Note: this will never make targetJitterTime larger than currentJitterTime due to
+		      //previous if condition
+		      if (thisJitter >  targetJitterTime_ * LOWER_JITTER_MAX_PCNT / 100) 
+		      {
+			targetJitterTime_ = thisJitter * 100 / LOWER_JITTER_MAX_PCNT;
+		      } 
+		  }
+	      }
+	      
+	      // writing here frame to codec, if it is the first one, record here delay
+	      
+	      talk.lastWrite_=talk.currentWrite_;
+	      
+	      if (talk.oldest_ == talk.newest_)
+	      {  // buffer play end.
+		  talk.newest_ = -1;
+		  talk.oldest_ = -1;
+	      }   
+	      else {
+      // 	    talk.oldest_ ->prev = NULL;
+		// If exceeded current jitter buffer time delay
+		if ((talk.timestamp_[talk.newest_] - talk.timestamp_[talk.currentWrite_]) > currentJitterTime_)
+		{
+		    consecutiveEarlyPacketStartTime_ = codecTime_;
+		    jitterCalcPacketCount_ = 0;
+		    jitterCalc_ = 0;
+		    talk.lastWrite_ = -1;
+		    
+		    // If we haven't yet written a frame, we get one free overrun
+		    if (!talk.doneFirstWrite_) 
+		    {
+	      
+			while ((talk.timestamp_[talk.newest_] - talk.timestamp_[talk.currentWrite_]) > currentJitterTime_) 
+			{
+			    // remove current Write frame
+			    talk.currentWrite_ = talk.oldest_;
+			    if (talk.oldest_<=talk.newest_)
+			    {  
+				talk.oldest_++;
+			      // increasing packet error rate due to frame deletion.
+			      per++;
+			    }
+			    if (talk.oldest_>talk.newest_ ) 
+			    {
+			      talk.oldest_= -1;
+			      talk.newest_= -1;
+			      break;
+			    }
+		      }
+	      
+			talk.doneFirstWrite_ = TRUE;
+			if (delay<0) 
+			{
+			    delay=codecTime_-talk.timestamp_[talk.currentWrite_] ;
+			}
+			// continuing the codec main loop
+			continue;
+		}
+		
+	 // See if exceeded maximum jitter buffer time delay, waste them if so
+	  while ((talk.timestamp_[talk.newest_] - talk.timestamp_[talk.currentWrite_]) > maxJitterTime_) 
+	  {
+	      currentJitterTime_ = maxJitterTime_;
+	      // remove current Write frame
+	      talk.currentWrite_ = talk.oldest_;
+	      if (talk.oldest_<=talk.newest_)
+	      {
+		talk.oldest_++; 
+
+	      // increasing packet error rate due to frame deletion.
+	      per++;
+	      }
+	      
+	      if (talk.oldest_>talk.newest_ ) 
+	      {
+		talk.oldest_= -1;
+		talk.newest_= -1;
+		break;
+	      }
+	  }
+	  
+	  
+	  // Now change the jitter time to cope with the new size
+    // unless already set to maxJitterTime
+      if (newestTimestamp - talk.timestamp_[talk.currentWrite_] > currentJitterTime_) 
+          currentJitterTime_ = newestTimestamp - talk.timestamp_[talk.currentWrite_];
+
+      targetJitterTime_ = currentJitterTime_;
+     }
+  }
+  
+  
+  if (( (codecTime_ - consecutiveEarlyPacketStartTime_) > DECREASE_JITTER_PERIOD) &&
+       (jitterCalcPacketCount_ >= DECREASE_JITTER_MIN_PACKETS))
+    {
+      jitterCalc_ = jitterCalc_ * 100 / LOWER_JITTER_MAX_PCNT;
+      if (jitterCalc_ < targetJitterTime_ / 2) jitterCalc_ = targetJitterTime_ / 2;
+      if (jitterCalc_ < minJitterTime_) jitterCalc_ = minJitterTime_;
+      targetJitterTime_ = jitterCalc_;
+      jitterCalc_ = 0;
+      jitterCalcPacketCount_ = 0;
+      consecutiveEarlyPacketStartTime_ = codecTime_;
+    }
+
+
+    /* If using immediate jitter reduction (rather than waiting for silence opportunities)
+  then trash oldest frames as necessary to reduce the size of the jitter buffer */
+  if (targetJitterTime_ < currentJitterTime_ &&
+      doJitterReductionImmediately_ &&
+      talk.newest_ > -1) {
+    while ((talk.timestamp_[talk.newest_] - talk.timestamp_[talk.currentWrite_]) > targetJitterTime_)
+    {
+      // Throw away the newest entries
+      if (talk.newest_>=talk.oldest_)
+      {
+	  talk.newest_--; 
+	  talk.received_--; 
+	  
+	      // increasing packet error rate due to frame deletion.
+	      per++;
+      }      
+      
+      
+      // Reset jitter calculation baseline
+      talk.lastWrite_ = -1;
+      
+
+      
+      if (talk.newest_ < 0) 
+      {
+          talk.oldest_ = -1;
+	  talk.received_= 0;
+          break;
+      }
+    }
+
+    currentJitterTime_ = targetJitterTime_;
+  }
+
+  talk.doneFirstWrite_ = TRUE;
+  if (delay<0) 
+  {
+      delay=codecTime_- talk.timestamp_[talk.currentWrite_];
+  }
+	 
+}// end codec loop
+	 
+	 per/=talk.nframes_;
+	 
+	 double mos = eModel ( delay , per );
+	 
+	 Stat::put ("voip_playout_talkspourt_delay", id_, delay);
+	 Stat::put ("voip_playout_talkspourt_per", id_, per );
+	 Stat::put ("voip_mos_distribution", id_, mos);
+	  Stat::put ("voip_satisfaction", id_,( mos >= mosThreshold_ ) ? 1.0 : 0);
+
+}
+
+void
+VoipDecoderH323::collectEnd ()
+{
+        unsigned int max = 0;
+        std::map<unsigned int, TalkData>::iterator it;
+        for ( it = talkData_.begin () ; it != talkData_.end () ; ++it )
+        {
+                if ( it == talkData_.begin() || it->first > max )
+                        max = it->first;
+        }
+        talkData_.erase ( max );
+        for ( it = talkData_.begin () ; it != talkData_.end () ; ++it )
+        {
+                collectTalkspurt ( it->first );
+        }
+
+		  // :TODO: add comment
+		  if ( peerId_ == -1 || id_ > peerId_ ) {
+			  if ( Stat::get ("voip_satisfaction", id_) >=
+					    cellOutageMosThreshold_ &&
+				    ( peerId_ == -1 || Stat::get ("voip_satisfaction", peerId_) >=
+					    cellOutageMosThreshold_ ) )
+				  Stat::put ("voip_cell_satisfaction", cellId_, 1.0);
+			  else
+				  Stat::put ("voip_cell_satisfaction", cellId_, 0);
+		  }
+
+	// Calculate MOS based on the entire conversation delay and loss
+	if ( endRecv_ != 0 ) {
+		endDelay_ /= endRecv_;
+		double endPer = ((double) endLost_) / (endLost_ + endRecv_ );
+		double endMos = eModel ( endDelay_ , endPer );
+		Stat::put("voip_mos_converstion", id_, endMos);
+	}
+        // Collect Gloabl metrics
+        // Call the base class collect End function.
+        VoipDecoder::collectEnd();
+}
diff --git a/ns-2.35/voip/voip_decoder_h323.h b/ns-2.35/voip/voip_decoder_h323.h
new file mode 100644
index 0000000..c1b04bb
--- /dev/null
+++ b/ns-2.35/voip/voip_decoder_h323.h
@@ -0,0 +1,107 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#ifndef __NS2_VOIP_DECODER_OPTIMAL_H
+#define __NS2_VOIP_DECODER_OPTIMAL_H
+
+#include <voip_decoder.h>
+#include <map>
+#include <vector>
+
+class VoipDecoderH323 : public VoipDecoder {
+public:
+	//! Create an empty VoIP decoder.
+	VoipDecoderH323 ();
+
+	//! Tcl interface.
+	int command (int argc, const char*const* argv);
+
+protected:
+	//! Collect statistics after playout buffering frame by frame.
+	virtual void collectFrame (VoipFrame& frame);
+	//! Collect statistics after playout buffering talkspurt by talkspurt.
+	void collectTalkspurt (unsigned int nframes);
+	//! Collect statistics after playout buffering at the end of simulation.
+	void collectEnd ();
+
+protected:
+
+	/*
+	 * Used for MOS calculation over the entire conversation
+	 * rather than for each talkspurt.
+	 */
+	//! Counter for lost packets
+	unsigned long endLost_;
+	//! Counter for received packets
+	unsigned long endRecv_;
+	//! per-conversation packet delay
+	double endDelay_;
+	//! decoder time- used in collect talkspurt
+	double codecTime_;
+	
+	//! prebuffering flag
+	bool prebuffering_;
+	
+	//! \todo
+	double minJitterTime_;
+	//! \todo 
+	double maxJitterTime_;
+	//! \todo
+	double currentJitterTime_;
+	//! \todo
+	double targetJitterTime_;
+	//! \todo
+	double consecutiveEarlyPacketStartTime_;
+	//! \todo
+	int jitterCalcPacketCount_;
+	//! \todo
+	double jitterCalc_;
+	
+	//! flag to enable immediate jitter reduction (otherwise jitter reduction is performed on-silence)
+	bool doJitterReductionImmediately_;
+	
+	//! Talkspurt data structure.
+	struct TalkData {
+		//! Timestamps in seconds.
+		std::vector<double> timestamp_;
+		//! arrival times in seconds.
+		std::vector<double> tick_;
+		//! flag to signal first write of the talk
+		bool doneFirstWrite_;
+		//! current frame to send to the decoder
+		int currentWrite_;
+		//! last played out frame
+		int lastWrite_;
+		//! last received frame 
+		int lastRead_;
+		//! oldest frame still to be played out
+		int oldest_;
+		//! newest frame in dejitter buffer
+		int newest_;
+		//! Number of frames in this talkspurt.
+		unsigned int nframes_;
+		//! Number of frames received so far.
+		unsigned int received_;
+		//! Statistics collection flag
+		bool statActive_;
+
+		//! Create an empty talkspurt data structure.
+		TalkData () {
+			doneFirstWrite_ =false;
+			nframes_    = 0;
+			received_   = 0;
+			currentWrite_ =-1;
+			lastRead_   = -1;
+			lastWrite_  = -1;
+			oldest_	    = 0;
+			newest_     = -1;
+			statActive_ = false;
+		}
+	};
+
+	//! One talkspurt data structure for each talkspurt ID.
+	std::map<unsigned int, TalkData> talkData_;
+};
+
+#endif // __NS2_VOIP_DECODER_OPTIMAL_H
diff --git a/ns-2.35/voip/voip_decoder_optimal.cc b/ns-2.35/voip/voip_decoder_optimal.cc
new file mode 100644
index 0000000..1d2e0c3
--- /dev/null
+++ b/ns-2.35/voip/voip_decoder_optimal.cc
@@ -0,0 +1,169 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#include <voip_decoder_optimal.h>
+#include <stat.h>
+#include <math.h>
+#include <stdio.h>
+
+static class VoipDecoderOptimalClass : public TclClass
+{
+        public:
+                VoipDecoderOptimalClass() : TclClass ( "Application/VoipDecoderOptimal" ) {}
+                TclObject* create ( int, const char*const* )
+                {
+                        return ( new VoipDecoderOptimal );
+                }
+}
+class_voip_decoder_optimal;
+
+VoipDecoderOptimal::VoipDecoderOptimal ()
+{
+	endLost_ = 0;
+	endRecv_ = 0;
+	endDelay_ = 0;
+}
+
+int
+VoipDecoderOptimal::command ( int argc, const char*const* argv )
+{
+        return VoipDecoder::command ( argc, argv );
+}
+
+void
+VoipDecoderOptimal::collectFrame ( VoipFrame& frame )
+{
+        // Access/add the current talkspurt data.
+        TalkData& talk = talkData_[frame.talkspurt_];
+
+        // If this is the first frame of this talkspurt, then update data.
+        if ( talk.nframes_ == 0 )
+        {
+		talk.statActive_ = Stat::active();
+                talk.nframes_ = frame.nframes_;
+                talk.delay_.resize ( talk.nframes_, -1.0 );
+        }
+
+        // Update the number of received frames.
+        if ( talk.delay_[frame.frame_] < 0 ) ++talk.received_;
+
+        // Add/update the delay sample for the current frame.
+        double delay = NOW - frame.timestamp_;
+        if ( talk.delay_[frame.frame_] < 0 || talk.delay_[frame.frame_] > delay )
+        {
+                talk.delay_[frame.frame_] = delay;
+        }
+
+        if ( talk.nframes_ == talk.received_ )
+        {
+                // If the last frame of this talkspurt has been added, then
+                // compute the measures for this talkspurt.
+                collectTalkspurt ( frame.talkspurt_ );
+
+                // Remove this talkspurt.
+                talkData_.erase ( frame.talkspurt_ );
+        }
+}
+
+void
+VoipDecoderOptimal::collectTalkspurt ( unsigned int nframes )
+{
+	  // Access the current talkspurt data.
+	  TalkData& talk = talkData_[nframes];
+
+	  if ( ! talk.statActive_ ) return;
+
+	  double bestMos  = -1.0;
+	  double bestRcvd = 0.0;
+	  double bestDelay = 0.0;
+	  double bestPer = 0.0;
+
+	  // Get the optimal value of the delay for this talkspurt.
+	  for ( unsigned int i = 0 ; i < talk.nframes_ ; i++ )
+	  {
+				 double per   = 0;
+				 double rcvd  = 0;
+				 double delay = talk.delay_[i];
+				 if ( delay < 0 ) continue;
+
+				 // Compute the packet loss with this delay.
+				 for ( unsigned int j = 0 ; j < talk.nframes_ ; j++ )
+				 {
+					 if ( talk.delay_[j] < 0 || talk.delay_[j] > delay ) {
+						 ++per;
+					 }
+					 else {
+					 	++rcvd;
+					 }
+				 }
+				 per /= talk.nframes_;
+
+				 double mos = eModel ( delay, per );
+
+				 if ( bestMos < 0 || mos > bestMos )
+				 {
+							bestMos = mos;
+							bestRcvd = rcvd;
+							bestDelay = delay;
+							bestPer = per;
+				 }
+	  }
+
+	  if ( bestMos > 0 ) {
+		  for ( unsigned int i = 0 ; i < talk.nframes_ ; i++ ) {
+			 if ( talk.delay_[i] < 0 || talk.delay_[i] > bestDelay ) {
+				 ++endLost_;
+			 }
+			 else {
+				endDelay_ += talk.delay_[i] + bestDelay;
+				++endRecv_;
+			 }
+
+		  }
+			Stat::put ("voip_playout_talkspurt_delay", id_, bestDelay);
+			Stat::put ("voip_playout_talkspurt_per", id_, bestPer );
+			Stat::put ("voip_mos_distribution", id_, bestMos);
+			Stat::put ("voip_satisfaction", id_,
+					( bestMos >= mosThreshold_ ) ? 1.0 : 0);
+	  }
+}
+
+void
+VoipDecoderOptimal::collectEnd ()
+{
+        unsigned int max = 0;
+        std::map<unsigned int, TalkData>::iterator it;
+        for ( it = talkData_.begin () ; it != talkData_.end () ; ++it )
+        {
+                if ( it == talkData_.begin() || it->first > max )
+                        max = it->first;
+        }
+        talkData_.erase ( max );
+        for ( it = talkData_.begin () ; it != talkData_.end () ; ++it )
+        {
+                collectTalkspurt ( it->first );
+        }
+
+		  // :TODO: add comment
+		  if ( peerId_ == -1 || id_ > peerId_ ) {
+			  if ( Stat::get ("voip_satisfaction", id_) >=
+					    cellOutageMosThreshold_ &&
+				    ( peerId_ == -1 || Stat::get ("voip_satisfaction", peerId_) >=
+					    cellOutageMosThreshold_ ) )
+				  Stat::put ("voip_cell_satisfaction", cellId_, 1.0);
+			  else
+				  Stat::put ("voip_cell_satisfaction", cellId_, 0);
+		  }
+
+	// Calculate MOS based on the entire conversation delay and loss
+	if ( endRecv_ != 0 ) {
+		endDelay_ /= endRecv_;
+		double endPer = ((double) endLost_) / (endLost_ + endRecv_ );
+		double endMos = eModel ( endDelay_ , endPer );
+		Stat::put("voip_mos_conversation", id_, endMos);
+	}
+        // Collect Gloabl metrics
+        // Call the base class collect End function.
+        VoipDecoder::collectEnd();
+}
diff --git a/ns-2.35/voip/voip_decoder_optimal.h b/ns-2.35/voip/voip_decoder_optimal.h
new file mode 100644
index 0000000..e4d8761
--- /dev/null
+++ b/ns-2.35/voip/voip_decoder_optimal.h
@@ -0,0 +1,64 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#ifndef __NS2_VOIP_DECODER_OPTIMAL_H
+#define __NS2_VOIP_DECODER_OPTIMAL_H
+
+#include <voip_decoder.h>
+#include <map>
+#include <vector>
+
+class VoipDecoderOptimal : public VoipDecoder {
+public:
+	//! Create an empty VoIP decoder.
+	VoipDecoderOptimal ();
+
+	//! Tcl interface.
+	int command (int argc, const char*const* argv);
+
+protected:
+	//! Collect statistics after playout buffering frame by frame.
+	virtual void collectFrame (VoipFrame& frame);
+	//! Collect statistics after playout buffering talkspurt by talkspurt.
+	void collectTalkspurt (unsigned int nframes);
+	//! Collect statistics after playout buffering at the end of simulation.
+	void collectEnd ();
+
+protected:
+
+	/*
+	 * Used for MOS calculation over the entire conversation
+	 * rather than for each talkspurt.
+	 */
+	//! Counter for lost packets
+	unsigned long endLost_;
+	//! Counter for received packets
+	unsigned long endRecv_;
+	//! per-conversation packet delay
+	double endDelay_;
+
+	//! Talkspurt data structure.
+	struct TalkData {
+		//! Delay samples, in seconds.
+		std::vector<double> delay_;
+		//! Number of frames in this talkspurt.
+		unsigned int nframes_;
+		//! Number of frames received so far.
+		unsigned int received_;
+		//! Statistics collection flag
+		bool statActive_;
+
+		//! Create an empty talkspurt data structure.
+		TalkData () {
+			nframes_    = 0;
+			received_   = 0;
+			statActive_ = false;
+		}
+	};
+
+	//! One talkspurt data structure for each talkspurt ID.
+	std::map<unsigned int, TalkData> talkData_;
+};
+
+#endif // __NS2_VOIP_DECODER_OPTIMAL_H
diff --git a/ns-2.35/voip/voip_decoder_static.cc b/ns-2.35/voip/voip_decoder_static.cc
new file mode 100644
index 0000000..9302cd4
--- /dev/null
+++ b/ns-2.35/voip/voip_decoder_static.cc
@@ -0,0 +1,264 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#include <voip_decoder_static.h>
+#include <stat.h>
+#include <math.h>
+#include <stdio.h>
+
+static class VoipDecoderStaticClass : public TclClass {
+public:
+        VoipDecoderStaticClass() : TclClass("Application/VoipDecoderStatic") {}
+        TclObject* create(int, const char*const*) {
+                return (new VoipDecoderStatic);
+        }
+} class_voip_decoder_static;
+
+VoipDecoderStatic::VoipDecoderStatic (): timer_(this)
+{
+        bufferOccupancy_ = 0;
+        bufferSize_ = 10;
+        initialDelay_ = 0.005;
+        playoutRate_ = 0.020;
+        talkLength_ = 0;
+        nextFrame_ = 0;
+        currentTalk_ = 0;
+}
+
+void
+VoipDecoderStatic::collectFrame (VoipFrame& frame)
+{
+        if (debug_) {
+                fprintf(stderr, "%.7f Received Frame [%d, %d of %d]\n",NOW, frame.talkspurt_, frame.frame_, frame.nframes_);
+                fprintf(stderr, "\tBuffer Occupancy: %d / %d\n", bufferOccupancy_, bufferSize_);
+        }
+        // Check if the frame belongs to an old talkspurt
+        if ( frame.talkspurt_ < currentTalk_) {
+                // Drop the frame
+                //Stat::put(VOIP_BUFFER_OUT_OF_TIME_DROP, id_, 1.0);
+                return;
+        }
+        // Check if there is space in the buffer and add the VoIP frames.
+        if (bufferOccupancy_ == bufferSize_) {
+                // A new frame is arrived and there is no free space in the
+                // buffer. 
+                // Check if the frame should be added or dropped, if added
+                // drop the first arrived frame in the buffer
+                if ( frame.talkspurt_ == currentTalk_ && frame.frame_ < buffer_.top().frame_  ) {
+                        // Ignore the frame, is too old.
+                        //Stat::put(VOIP_BUFFER_OUT_OF_TIME_DROP, id_, 1.0);
+                        return;
+                }
+                // Drop a frame from the head of the buffer 
+                buffer_.pop();
+                // Now store the packet into the buffer
+                // The bufferOccupancy_ remains the same
+                buffer_.push(frame);
+                // Note that, in this case nextFrame_ is manually set.
+                nextFrame_ = buffer_.top().frame_;
+                // Check if the next frame belongs to a new talkspurt
+                if (currentTalk_ < buffer_.top().talkspurt_) {
+                        collectTalkspurt(talkLength_);
+                        delaySum_ = 0;
+                        delayNum_ = 0;
+                        currentTalk_ = buffer_.top().talkspurt_;
+                        talkLength_ = buffer_.top().nframes_;
+                        nextFrame_ = 0;
+                        // A new talkspurt will begin
+                        // Check if the timer has been set
+                        if ( timer_.idle() ) {
+                                // It should never happen
+                                timer_.start(initialDelay_);
+                        }
+                }
+                //Stat::put(VOIP_BUFFER_OVERFLOW_DROP, id_, 1.0);
+        }
+        else {
+                // Now store the packet into the buffer
+                buffer_.push(frame);
+                bufferOccupancy_++;
+        }
+        // If the buffer was empty, start the playout timer and set the next
+        // sequence number to be played to the sequence number of this packet
+        if (bufferOccupancy_ == 1) {
+                // Check if the playout of this talkspurt has been already
+                // started. If yes, do nothing
+                if ( timer_.idle() ) {
+                        timer_.start( initialDelay_ );
+                        currentTalk_ = frame.talkspurt_;
+                        // Note that, we set the next sample to be played to
+                        // the first sample of the talkspurt.
+                        // In fact, we enter here if and only if the buffer
+                        // was empty and no talkspurt was under playing.
+                        nextFrame_ = 0;
+                        talkLength_ = frame.nframes_;
+                }
+        }
+}
+
+void
+VoipDecoderStatic::handle() 
+{
+        if (debug_) {
+                fprintf (stderr, "%.7f It's time to playout: [%d, %d]\n", NOW, currentTalk_, nextFrame_);
+        }
+        // When playout of a talkspurt is started, a frame is exctracted
+        // from the buffer every period. If no frames are found a loss is
+        // assumed.
+
+        // Drop all the old samples in the buffer
+        if (bufferOccupancy_ > 0) {
+                VoipFrame frame = buffer_.top();
+                while ( frame.frame_ < nextFrame_ ) {
+                        if (debug_) {
+                                fprintf(stderr, "\tFound out-of-time sample [%d, %d]\n", frame.talkspurt_, frame.frame_);
+                        }
+                        buffer_.pop();
+                        bufferOccupancy_ --;
+                        //Stat::put(VOIP_BUFFER_OUT_OF_TIME_DROP, id_, 1.0);
+                        if ( bufferOccupancy_ > 0 ) {
+                                frame = buffer_.top();
+                        }
+                        else {
+                                break;
+                        }
+                }
+        }
+        // If there are still frames in the buffer, try to playout the first
+        // frame
+        if (bufferOccupancy_ > 0) {
+                VoipFrame frame = buffer_.top();
+                // If talkLength_ is equal to zero, it means that no frames
+                // have been received belonging to current talkspurt.
+                if (talkLength_ == 0 && frame.talkspurt_ > currentTalk_) {
+                        // Assume that one or more talkspurts have been not
+                        // received
+                        currentTalk_ = frame.talkspurt_;
+                        nextFrame_ = 0;
+                        talkLength_ = frame.nframes_;
+                }
+                if (debug_) {
+                        fprintf (stderr, "%.7f Handling sample [%d, %d]\n", NOW, frame.talkspurt_, frame.frame_);
+                        fprintf (stderr, "\tExpected frame: [%d, %d]\n", currentTalk_, nextFrame_);
+                }
+                if ( frame.frame_ == nextFrame_ ) {
+                        if (debug_) {
+                                fprintf (stderr, "%.7f Playing sample [%d, %d]\n", NOW, frame.talkspurt_, frame.frame_);
+                        }
+                        // Playout the frame
+                        const double delay = NOW - frame.timestamp_;
+                        //Stat::put (VOIP_FRAME_DELAY, id_, delay);
+                        ++delayNum_;
+                        delaySum_ += delay;
+                        // This assignment assures that if at least one
+                        // frame of a talkspurt is received the talkLength_ 
+                        // contains the length of the talkspurt.
+                        talkLength_ = frame.nframes_;
+                        // Remove the frame from the buffer
+                        buffer_.pop();
+                        bufferOccupancy_--;
+                }
+        }
+        // Update the next frame variable
+        nextFrame_++;
+        // Check if this is the last frame of the talkspurt
+        if ( nextFrame_ == talkLength_ ) {
+                collectTalkspurt(talkLength_);
+                delaySum_ = 0;
+                delayNum_ = 0;
+                nextFrame_ = 0;
+                currentTalk_++;
+                if ( bufferOccupancy_ > 0 ) {
+                        if (buffer_.top().talkspurt_ == currentTalk_) {
+                                talkLength_ = buffer_.top().nframes_;
+                        }
+                        else {
+                                // There are no information about the next
+                                // talkspurt.
+                                // Note that, this means that all the frames
+                                // in the buffer are related to a future
+                                // talkspurts. e.g. the talkspurt after
+                                // the current one.
+                                talkLength_ = 0;
+                        }
+                        // Reschedule the timer for the next talkspurt
+                        timer_.start ( initialDelay_ );
+                }
+                // Otherwise, wait for a new talkspurt before restart
+                // the timer
+                else if (debug_) {
+                        fprintf(stderr, "%.7f The buffer is empty, wait for a new frame\n", NOW);
+                }
+        }
+        else {
+                timer_.start ( playoutRate_ );
+        }
+}
+
+int
+VoipDecoderStatic::command (int argc, const char*const* argv)
+{
+        if ( argc == 3 && strcmp (argv[1], "id") == 0 ) {
+                id_ = atoi(argv[2]);
+                // Initialize some counter metrics
+                //Stat::put(VOIP_BUFFER_OUT_OF_TIME_DROP, id_, 0.0);
+                //Stat::put(VOIP_BUFFER_OVERFLOW_DROP, id_, 0.0);
+                return VoipDecoder::command (argc, argv);
+
+        } else if ( argc == 3 && strcmp ( argv[1], "buffer-size" ) == 0 ) {
+                bufferSize_ = atoi ( argv[2] );
+                if ( bufferSize_ <= 0 ) {
+                        fprintf(stderr, "VoipDecoderStatic: Invalid buffer size: %d\n", bufferSize_);
+                        return TCL_ERROR;
+                }
+                return TCL_OK;
+
+        } else if ( argc == 3 && strcmp ( argv[1], "playout-rate" ) == 0 ) {
+                playoutRate_ = atof ( argv[2] );
+                if ( playoutRate_ <= 0 ) {
+                        fprintf(stderr, "VoipDecoderStatic: Invalid playout rate %f\n", playoutRate_);
+                        return TCL_ERROR;
+                }
+                return TCL_OK;
+
+        } else if ( argc == 3 && strcmp ( argv[1], "initial-delay" ) == 0 ) {
+                initialDelay_ = atof ( argv[2] );
+                if ( playoutRate_ <= 0 ) {
+                        fprintf(stderr, "VoipDecoderStatic: Invalid initial delay %f\n", initialDelay_);
+                        return TCL_ERROR;
+                }
+                return TCL_OK;
+        }
+
+        // For more detail, please refer to ITU-T Recommendation G.113
+        else if ( argc == 3 && strcmp ( argv[1], "emodel" ) == 0 ) {
+                if ( strcmp ( argv[2], "G.711" ) == 0 ) {
+                        playoutRate_ = 0.010;
+                        return VoipDecoder::command(argc, argv);
+
+                } else if ( strcmp ( argv[2], "G.729A_VAD" ) == 0 ) {
+                        playoutRate_ = 0.020;
+                        return VoipDecoder::command(argc, argv);
+
+                } else if ( strcmp ( argv[2], "G.723.1_VAD" ) == 0 ) {
+                        playoutRate_ = 0.030;
+                        return VoipDecoder::command(argc, argv);
+
+                } else if ( strcmp ( argv[2], "GSM.EFR" ) == 0 ) {
+                        playoutRate_ = 0.020;
+                        return VoipDecoder::command(argc, argv);
+
+                } else if ( strcmp ( argv[2], "GSM.AMR" ) == 0 ) {
+                        playoutRate_ = 0.020;
+                        return VoipDecoder::command(argc, argv);
+
+                } else {
+                        fprintf(stderr, "VoipDecoder - Unsupported Codec\n");
+                        return TCL_ERROR;
+                }
+        }
+
+        return VoipDecoder::command (argc, argv);
+}
+
diff --git a/ns-2.35/voip/voip_decoder_static.h b/ns-2.35/voip/voip_decoder_static.h
new file mode 100644
index 0000000..ccb0dd7
--- /dev/null
+++ b/ns-2.35/voip/voip_decoder_static.h
@@ -0,0 +1,62 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#ifndef __NS2_VOIP_DECODER_STATIC_H
+#define __NS2_VOIP_DECODER_STATIC_H
+
+#include <voip_decoder.h>
+
+#include <t_timers.h>
+#include <queue>
+
+
+class VoipDecoderStatic : public VoipDecoder {
+public:
+        //! Create an empty VoIP decoder.
+        VoipDecoderStatic ();
+
+        //! Tcl interface.
+        int command (int argc, const char*const* argv);
+
+        //! Periodic playout timer
+        void handle();
+
+protected:
+        //! Collect statistics after playout buffering frame by frame.
+        void collectFrame (VoipFrame& frame);
+
+protected:
+        //! Frame buffer
+        std::priority_queue< VoipFrame > buffer_;
+
+        //! Next frame to be played out
+        unsigned int nextFrame_;
+
+        //! Length of the current talk (in frames)
+        unsigned int talkLength_;
+
+        //! Playout sample rate (in ms)
+        double playoutRate_;
+
+        //! Playout initial delay
+        /** Delay of the first sample of the talkspurt
+         */
+        double initialDelay_;
+
+        //! Playout buffer size.
+        /** It is expressed in terms of number of VoIP samples, not in
+         *  number of IP Packets!
+         */
+        int bufferSize_;
+
+        //! Current buffer occupancy
+        int bufferOccupancy_;
+
+        //! T_Timer
+        /** The timer is used to manage playout samples
+         */
+        TTimer<VoipDecoderStatic> timer_;
+};
+
+#endif // __NS2_VOIP_DECODER_STATIC_H
diff --git a/ns-2.35/voip/voip_encoder.cc b/ns-2.35/voip/voip_encoder.cc
new file mode 100644
index 0000000..5df1d06
--- /dev/null
+++ b/ns-2.35/voip/voip_encoder.cc
@@ -0,0 +1,169 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#include <voip_encoder.h>
+#include <voip_frame.h>
+#include <voip_aggregate.h>
+#include <voip_header.h>
+#include <stat.h>
+#include <math.h>
+#include <stdio.h>
+
+static class VoipEncoderClass : public TclClass {
+public:
+        VoipEncoderClass() : TclClass("Application/VoipEncoder") {}
+        TclObject* create(int, const char*const*) {
+                return (new VoipEncoder);
+        }
+} class_voip_encoder;
+
+VoipEncoder::VoipEncoder () : timer_ (this)
+{
+    size_           = 0;
+    inter_          = 0;
+    initialized_    = false;
+    debug_          = false;
+    header_         = 0;
+    aggregate_      = 0;
+    agent_          = 0;        // base class member
+}
+
+int
+VoipEncoder::command (int argc, const char*const* argv)
+{
+    if ( argc == 2  && strcmp (argv[1], "debug") == 0 ) {
+        debug_ = true;
+        return TCL_OK;
+
+    } else if ( argc == 2  && strcmp (argv[1], "nodebug") == 0 ) {
+        debug_ = false;
+        return TCL_OK;
+
+    } else if ( argc == 2 && strcmp (argv[1], "inter") == 0 )  {
+        Tcl::instance ().resultf ("%f", inter_);
+        return TCL_OK;
+
+    } else if ( argc == 3  && strcmp (argv[1], "aggregate") == 0 ) {
+        aggregate_ = (VoipAggregate*) TclObject::lookup (argv[2]);
+        return TCL_OK;
+
+    } else if ( argc == 3  && strcmp (argv[1], "header") == 0 ) {
+        header_ = (VoipHeader*) TclObject::lookup (argv[2]);
+        return TCL_OK;
+
+    } else if ( argc == 3 && strcmp (argv[1], "id") == 0 ) {
+        id_ = atoi(argv[2]);
+        if (id_ < 0) {
+            fprintf (stderr, "VoIP Encoder: Invalid id(%d)\n", id_);
+            return TCL_ERROR;
+        }
+        return TCL_OK;
+
+    } else if ( argc >= 3 && strcmp (argv[1], "codec") == 0 ) {
+        if ( argc == 3 && strcmp (argv[2], "G.711") == 0 ) {
+            size_ = 80;
+            inter_ = 0.01;
+            initialized_ = true;
+            return TCL_OK;
+
+        } else if ( argc == 3 && strcmp (argv[2], "GSM.AMR") == 0 ) {
+            size_ = 32;
+            inter_ = 0.02;
+            initialized_ = true;
+            return TCL_OK;
+
+        } else if ( argc == 3 && strcmp (argv[2], "G.729A") == 0 ) {
+            size_ = 20;
+            inter_ = 0.02;
+            initialized_ = true;
+            return TCL_OK;
+
+        } else if ( argc == 3 && strcmp (argv[2], "G.723.1") == 0 ) {
+            size_ = 24;
+            inter_ = 0.03;
+            initialized_ = true;
+            return TCL_OK;
+
+        } else if ( argc == 3 && strcmp (argv[2], "GSM.EFR") == 0 ) {
+            size_ = 32;
+            inter_ = 0.02;
+            initialized_ = true;
+            return TCL_OK;
+        //
+        // Add *here* your codec.
+        //
+        // if ( argc == X && strcmp (argv[2], "X") == 0 ) {
+        // 	return TCL_OK;
+        //
+        } else {
+            fprintf (stderr, "Unknown codec '%s'\n", argv[2]);
+            return TCL_ERROR;
+        }
+        return TCL_OK;
+    }
+    return Application::command (argc, argv);
+}
+
+void
+VoipEncoder::handle (unsigned int count)
+{
+    if ( ! initialized () ) {
+        fprintf (stderr, "VoIP encoder not initialized");
+        abort ();
+    }
+
+    if ( debug_ ) fprintf (stderr,
+        "%.9f new frame (%d bytes) for talkspurt %d, %d to go\n",
+            NOW, size_, count, remaining_[count]);
+
+    // Create a new frame.
+    VoipFrame frame (size_, count,
+        total_[count] - remaining_[count], total_[count]);
+
+    // Count the number of frames sent
+    Stat::put("voip_frames_sent",id_,1);
+
+    // Send the frame to the aggregate object, if present.
+    if ( aggregate_ ) {
+        aggregate_->recv (frame);
+
+    // Otherwise, send it to the agent.
+    } else {
+        // Create a new payload.
+        VoipPayload* payload = new VoipPayload;
+        (*payload) += frame;
+
+        // Send the frame to the header module, if present.
+        if ( header_ ) {
+            header_->recvPayload(size_, payload);
+        } else {
+            // Send out the payload to the agent.
+            agent_->sendmsg (size_, (AppData*)payload);
+        }
+    }
+
+    // Update the remaining frames to be generated.
+    --remaining_[count];
+
+    // If this is not the last frame to generate, re-start the timer.
+    if ( remaining_[count] > 0 ) timer_.add (inter_, count);
+}
+
+void
+VoipEncoder::talkspurt (unsigned int count, double duration)
+{
+    if ( debug_ ) fprintf (stderr,
+        "%.9f flow id %u talkspurt %d start (duration %f)\n",
+            NOW, id_, count, duration);
+
+    unsigned int remaining = (unsigned int) round ( duration / inter_ );
+    if ( remaining == 0 ) remaining = 1;
+
+    // Update the remaining frames to be generated.
+    total_[count] = remaining;
+    remaining_[count] = remaining;
+
+    // Generate the first frame of this talkspurt.
+    handle (count);
+}
diff --git a/ns-2.35/voip/voip_encoder.h b/ns-2.35/voip/voip_encoder.h
new file mode 100644
index 0000000..ff18fc3
--- /dev/null
+++ b/ns-2.35/voip/voip_encoder.h
@@ -0,0 +1,87 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#ifndef __NS2_VOIP_ENCODER_H
+#define __NS2_VOIP_ENCODER_H
+
+#include <app.h>
+#include <object.h>
+#include <t_timers.h>
+#include <map>
+
+class VoipAggregate;
+class VoipHeader;
+
+class VoipEncoder : public Application {
+public:
+        //! Create an empty VoIP source.
+        VoipEncoder ();
+
+        //! Return true if the object is ready to be started.
+        bool initialized () { return initialized_; }
+
+        //! Tcl interface.
+        /*!
+                * Tcl commands:
+                * - $obj debug\n
+                *   Enable debug to standard error.
+                * - $obj nodebug\n
+                *   Disable debug to standard error (default).
+                * - $obj codec $code_type
+                *   Select the codec to be used
+                *   The followinf codecs are actually implemented:
+                *   <ul>
+                *    <li>
+                *     G.711 - (64kbps): 80 bytes VoIP frame, 100 frames per second.
+                *    </li>
+                *    <li>
+                *     GSM AMR - (12.2kbps): 32 bytes VoIP frame, 50 frames per second.
+                *              Note that, 244 bits payload, 4 bit padding, 1 byte EOF
+                *    </li>
+                *   </ul>
+                */
+        virtual int command (int argc, const char*const* argv);
+
+        //! Produce frames for a new talkspurt.
+        void talkspurt (unsigned int count, double duration);
+
+        //! Generate a new talkspurt.
+        void handle (unsigned int count);
+
+protected:
+        //! Timer to schedule frames.
+        /*!
+                * The timer is called at the beginning of each talkspurt.
+                */
+        TMultiTimer<VoipEncoder, unsigned int> timer_;
+
+        //! Frame size, in bytes.
+        unsigned int size_;
+
+        //! Interval between two consecutive frames, in seconds.
+        double inter_;
+
+        //! Number of remaining frames to generate for a given talkspurt.
+        std::map<unsigned int, unsigned int> remaining_;
+
+        //! Number of frames to generate for a given talkspurt.
+        std::map<unsigned int, unsigned int> total_;
+
+        //! Statistic Metric ID
+        int id_;
+
+        //! Aggregate object, if present.
+        VoipAggregate* aggregate_;
+
+        //! Pointer to the VoIP Header Module, if present
+        VoipHeader* header_;
+
+        //! True if debug is enabled.
+        bool debug_;
+
+        //! True if the object is ready to produce frames.
+        bool initialized_;
+};
+
+#endif // __NS2_VOIP_ENCODER_H
diff --git a/ns-2.35/voip/voip_frame.h b/ns-2.35/voip/voip_frame.h
new file mode 100644
index 0000000..c050495
--- /dev/null
+++ b/ns-2.35/voip/voip_frame.h
@@ -0,0 +1,96 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#ifndef __NS2_VOIP_FRAME_H
+#define __NS2_VOIP_FRAME_H
+
+#include <ns-process.h>
+#include <object.h>
+#include <list>
+#include <stat.h>
+
+struct VoipFrame {
+        //! Talkspurt identifier.
+        unsigned int talkspurt_;
+        //! Frame identifier within talkspurt.
+        unsigned int frame_;
+        //! Number of frames in this talkspurt.
+        unsigned int nframes_;
+        //! Size, in bytes of this frame.
+        unsigned int size_;
+        //! Frame generation timestamp, in seconds.
+        double timestamp_;
+	//! Statistics collection flag
+	bool statActive_;
+
+        //! Create an empty VoIP frame.
+        VoipFrame (unsigned int size = 0,
+                   unsigned int talkspurt = 0,
+                   unsigned int frame = 0,
+                   unsigned int nframes = 0) {
+                size_ = size;
+                talkspurt_ = talkspurt;
+                frame_ = frame;
+                nframes_ = nframes;
+                timestamp_ = NOW;
+		statActive_ = Stat::active();
+        }
+
+        //! Stric weak ordering among VoIP frames
+        bool operator<(const VoipFrame& frame) const {
+                if ( talkspurt_ > frame.talkspurt_ ) {
+                        return true;
+                }
+                else if ( talkspurt_ == frame.talkspurt_ && frame_ > frame.frame_ ) {
+                        return true;
+                }
+                return false;
+        }
+};
+
+struct VoipPayload : public AppData {
+public:
+        typedef std::list<VoipFrame> List;
+
+        //! Create a VoIP payload with no frames.
+        VoipPayload () : AppData (VOIP_DATA) { nframes_ = 0; }
+        //! Copy constructor.
+        VoipPayload (VoipPayload& p) : AppData (p) {
+                nframes_ = p.nframes_;
+                frames_ = p.frames_;
+        }
+
+        //! Deallocate the payload.
+        ~VoipPayload () { }
+
+        //! Add a VoIP frame.
+        void operator+= (const VoipFrame& frame) {
+                frames_.push_back (frame);
+                ++nframes_;
+        }
+        //! Pop the first VoIP frame and return it.
+        VoipFrame operator-- () {
+                if ( nframes_ == 0 ) abort ();
+                VoipFrame first = frames_.front();
+                frames_.pop_front ();
+                --nframes_;
+                return first;
+        }
+        //! Get the number of frames.
+        unsigned int nframes () { return nframes_; }
+
+        //! Return the memory occupancy (required by the base class).
+        int size() const { return sizeof(VoipPayload); }
+
+        //! Copy this object (required by the base class).
+        AppData* copy() { return (new VoipPayload(*this)); }
+
+private:
+        //! Number of VoIP frames contained into this payload.
+        unsigned int nframes_;
+        //! List of VoIP frames contained into this payload.
+        List frames_;
+};
+
+#endif // __NS2_VOIP_FRAME_H
diff --git a/ns-2.35/voip/voip_header.cc b/ns-2.35/voip/voip_header.cc
new file mode 100644
index 0000000..da034ab
--- /dev/null
+++ b/ns-2.35/voip/voip_header.cc
@@ -0,0 +1,65 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#include <voip_header.h>
+#include <stdio.h>
+
+static class VoipHeaderClass : public TclClass {
+        public:
+                VoipHeaderClass() : TclClass("Application/VoipHeader") {}
+                TclObject* create(int, const char*const*) {
+                        return (new VoipHeader);
+                }
+} class_voip_header;
+
+VoipHeader::VoipHeader()
+{
+        debug_           = false;
+        initialized_     = false;
+        compression_     = false;
+        size_            = 40;
+
+        agent_           = 0;        // base class member
+}
+
+int
+VoipHeader::command (int argc, const char*const* argv)
+{
+        if ( argc == 2  && strcmp (argv[1], "debug") == 0 ) {
+                debug_ = true;
+                return TCL_OK;
+
+        } else if ( argc == 2  && strcmp (argv[1], "nodebug") == 0 ) {
+                debug_ = false;
+                return TCL_OK;
+
+        } else if ( argc == 2  && strcmp (argv[1], "compression") == 0 ) {
+                compression_ = true;
+                size_ = 6;
+                return TCL_OK;
+
+	} else if ( argc == 3  && strcmp (argv[1], "compression") == 0 ) {
+				compression_ = true;
+				size_ = atoi(argv[2]);
+				return TCL_OK;
+
+        } else if ( argc == 2  && strcmp (argv[1], "nocompression") == 0 ) {
+                compression_ = false;
+                size_ = 40;
+                return TCL_OK;
+
+        } else if ( argc == 2  && strcmp (argv[1], "algorithm") == 0 ) {
+                fprintf(stderr, "Header Compression Algorithm. To Be Implemented\n");
+                return TCL_ERROR;
+        }
+
+        return Application::command (argc, argv);
+}
+
+void 
+VoipHeader::recvPayload (int size, VoipPayload* data)
+{
+        int payloadSize = size_ + size;
+	agent_->sendmsg(payloadSize, (AppData*)data);
+}
diff --git a/ns-2.35/voip/voip_header.h b/ns-2.35/voip/voip_header.h
new file mode 100644
index 0000000..4bb15d4
--- /dev/null
+++ b/ns-2.35/voip/voip_header.h
@@ -0,0 +1,55 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#ifndef __NS2_VOIP_HEADER_H
+#define __NS2_VOIP_HEADER_H
+
+#include <voip_frame.h>
+
+#include <app.h>
+#include <object.h>
+
+class VoipHeader : public Application {
+public:
+        //! Create an empty VoIP Header.
+        VoipHeader ();
+
+        //! Do Nothing
+        ~VoipHeader() { }
+
+        //! Return true if the object is ready to be started.
+        bool initialized () { return initialized_; }
+
+        //! Tcl interface.
+        /*!
+         * Tcl commands:
+         * - $obj debug\n
+         *   Enable debug to standard error.
+         * - $obj nodebug\n
+         *   Disable debug to standard error (default).
+         */
+        virtual int command (int argc, const char*const* argv);
+
+        //! Produce frames for a new talkspurt.
+        void recvPayload (int noBytes, VoipPayload* data);
+
+protected:
+
+        //! True if debug is enabled.
+        bool debug_;
+
+        //! True if the object is ready to produce frames.
+        bool initialized_;
+
+        //! True if header compression is enabled.
+        // This variable will allow us to implement new header
+        // compression policy based on real compression algorithms. 
+        // Currently this variable is not used.
+        bool compression_;
+
+        //! Header size (RTP + UDP + IP) in bytes
+        unsigned int size_;
+};
+
+#endif // __NS2_VOIP_HEADER_H
diff --git a/ns-2.35/voip/voip_source.cc b/ns-2.35/voip/voip_source.cc
new file mode 100644
index 0000000..cc0de45
--- /dev/null
+++ b/ns-2.35/voip/voip_source.cc
@@ -0,0 +1,187 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#include <voip_source.h>
+#include <voip_encoder.h>
+#include <voip_bidirectional.h>
+#include <ranvar.h>
+#include <stdio.h>
+
+#include <stat.h>
+
+static class VoipSourceClass : public TclClass {
+public:
+    VoipSourceClass() : TclClass("VoipSource") { }
+    TclObject* create(int, const char*const*) {
+        return (new VoipSource);
+    }
+} class_voip_source;
+
+VoipSource::VoipSource () : timer_(this), talk1_(1.423, 0.824), silence1_(0.899, 1.089)
+{
+    encoder_        = 0;
+    talk_           = 0;
+    silence_        = 0;
+    count_          = 0;
+    debug_          = false;
+    stat_           = false;
+    fid_            = 0;
+    bidirectional_  = 0;
+}
+
+int
+VoipSource::command (int argc, const char*const* argv)
+{
+    if ( argc == 3  && strcmp (argv[1], "stat") == 0 ) {
+        stat_ = true;
+        fid_ = atoi(argv[2]);
+        return TCL_OK;
+        
+    } else if ( argc == 2  && strcmp (argv[1], "debug") == 0 ) {
+        debug_ = true;
+        return TCL_OK;
+
+    } else if ( argc == 2  && strcmp (argv[1], "nodebug") == 0 ) {
+        debug_ = false;
+        return TCL_OK;
+
+    } else if ( argc == 2  && strcmp (argv[1], "start") == 0 ) {
+        handle ();
+        return TCL_OK;
+
+    } else if ( argc == 2  && strcmp (argv[1], "stop") == 0 ) {
+        stop ();
+        return TCL_OK;
+
+    } else if ( argc == 3 && strcmp (argv[1], "encoder") == 0 ) {
+        encoder_ = (VoipEncoder*) TclObject::lookup (argv[2]);
+        return TCL_OK;
+
+    } else if ( argc == 3 && strcmp (argv[1], "bidirectional") == 0 ) {
+        bidirectional_ = (VoipBidirectional*) TclObject::lookup (argv[2]);
+        return TCL_OK;
+
+    } else if ( argc >= 3 && strcmp (argv[1], "model") == 0 ) {
+        if ( argc == 5 && strcmp (argv[2], "exponential") == 0 ) {
+
+            // Retrieve and check input parameters from Tcl.
+            double talk = atof (argv[3]);
+            double silence = atof (argv[4]);
+            if ( talk <= 0 || silence <= 0 ) {
+                fprintf (stderr, "Invalid exponential parameters talk '%f', silence '%f'\n", talk, silence);
+                return TCL_ERROR;
+            }
+
+            // Create and initialize the random variables
+            // to schedule talkspurts and silence periods.
+            //! \todo
+            //! Andrea: Dynamic cast seems to introduce some strange
+            //! behaviour! CHECK CHECK CHECK.
+            talk_ = new ExponentialRandomVariable;
+            dynamic_cast<ExponentialRandomVariable*>(talk_)->setavg (talk);
+            silence_ = new ExponentialRandomVariable;
+            dynamic_cast<ExponentialRandomVariable*>(silence_)->setavg (silence);
+            return TCL_OK;
+
+            //
+            // Add *here* your VoIP source model.
+            //
+            // if ( argc == X && strcmp (argv[2], "X") == 0 ) {
+            // 	return TCL_OK;
+            //
+        } else if ( argc == 3 && strcmp (argv[2], "one-to-one") == 0 ) {
+            // Retrieve and check input parameters from Tcl.
+            // Create and initialize the random variables
+            // to schedule talkspurts and silence periods.
+            talk_ = new WeibullRandomVariable(1.423, 0.824);
+            silence_ = new WeibullRandomVariable(0.899, 1.089);
+            return TCL_OK;
+
+        } else if ( argc == 3 && strcmp (argv[2], "many-to-many") == 0 ) {
+            // Retrieve and check input parameters from Tcl.
+            // Create and initialize the random variables
+            // to schedule talkspurts and silence periods.
+            talk_ = new WeibullRandomVariable(2.184, 0.435);
+            silence_ = new WeibullRandomVariable(3.093, 0.450);
+            return TCL_OK;
+
+        } else if ( argc == 3 && strcmp (argv[2], "one-to-many") == 0 ) {
+            // Retrieve and check input parameters from Tcl.
+            // Create and initialize the random variables
+            // to schedule talkspurts and silence periods.
+            talk_ = new WeibullRandomVariable(23.952, 1.278);
+            silence_ = new WeibullRandomVariable(3.941, 0.820);
+            return TCL_OK;
+
+        } else if ( argc == 3 && strcmp (argv[2], "many-to-one") == 0 ) {
+            // Retrieve and check input parameters from Tcl.
+            // Create and initialize the random variables
+            // to schedule talkspurts and silence periods.
+            talk_ = new WeibullRandomVariable(3.342, 0.732);
+            silence_ = new WeibullRandomVariable(44.267, 0.432);
+            return TCL_OK;
+
+        } else if ( argc == 7 && strcmp (argv[2], "weibull-custom") == 0 ) {
+            talk_    = new WeibullRandomVariable( atof(argv[3]), atof(argv[4]) );
+            silence_ = new WeibullRandomVariable( atof(argv[5]), atof(argv[6]) );
+            return TCL_OK;
+	    } else {
+		    fprintf (stderr, "Unknown VoIP source model '%s'\n", argv[2]);
+            return TCL_ERROR;
+        }
+	    return TCL_OK;
+    }
+    return TCL_ERROR;
+}
+
+void
+VoipSource::handle ()
+{
+    if ( ! initialized () ) {
+        fprintf (stderr, "VoIP source not initialized");
+        abort ();
+    }
+
+    double talk    = 0.0;
+    double silence = 0.0;
+
+    // If there is a bidirectional module bound to this object
+    // then get the next talkspurt and silence periods from it.
+    if ( bidirectional_ ) {
+        bidirectional_->next (this, talk, silence);
+
+    // Otherwise, draw the talkspurt and silence period duration randomly
+    // from the random variables depending on the source model.
+    } else {
+        talk = talk_->value();
+        silence = silence_->value();
+    }
+
+    if ( debug_ ) fprintf (stderr, "%.9f new talkspurt %f, %f (ID %d)\n",
+            NOW, talk, silence, count_);
+
+	if ( talk > 0.0 ) {
+        // Tell the encoder that a new talkspurt is to be generated.
+        encoder_->talkspurt (count_, talk);
+
+	    // Update the talkspurt counter.
+        ++count_;
+		// Collect some statistics useful for debug purposes
+		if ( stat_ )
+        {
+			Stat::put ("voip_talkspurt_duration", 0, talk );
+            //Stat::put (VOIP_DUR_FID_TALK, fid_, talk);
+        }
+	}
+
+	// Collect some statistics useful for debug purposes
+	if ( silence > 0.0 && stat_ )
+    {
+		Stat::put ("voip_silence_duration", 0, silence );
+        Stat::put ("voip_dur_fid_silence", fid_, silence);
+    }
+    
+    // Reschedule this function to be called after the silence period.
+    timer_.start (talk + silence);
+}
diff --git a/ns-2.35/voip/voip_source.h b/ns-2.35/voip/voip_source.h
new file mode 100644
index 0000000..9d41b31
--- /dev/null
+++ b/ns-2.35/voip/voip_source.h
@@ -0,0 +1,85 @@
+/*
+ * TODO: INSERT LICENSE HERE
+ */
+
+#ifndef __NS2_VOIP_SOURCE_H
+#define __NS2_VOIP_SOURCE_H
+
+#include <object.h>
+#include <t_timers.h>
+
+#include <ranvar.h>
+
+class VoipEncoder;
+class RandomVariable;
+
+class VoipBidirectional;
+
+class VoipSource : public TclObject {
+public:
+    //! Create an empty VoIP source.
+    VoipSource ();
+
+    //! Return true if the object is ready to be started.
+    bool initialized () {
+        return ( encoder_ && talk_ && silence_ ) || bidirectional_; }
+
+    //! Tcl interface.
+    /*!
+         * Tcl commands:
+         * - $obj debug\n
+         *   Enable debug to standard error.
+         * - $obj nodebug\n
+         *   Disable debug to standard error (default).
+         * - $obj start\n
+         *   Start the first talkspurt generated by this VoIP source.
+         * - $obj stop\n
+         *   Do not generate any more talkspurts until resumed.
+         * - $obj model exponential T S\n
+         *   Draw the talkspurt and silence periods randomly from two
+         *   exponential distributions with average T and S, respectively.
+         * - $obj encoder $enc\n
+         *   Bind the VoIP encoder $enc to this object $obj.
+         * - $obj bidirectional $bidir\n
+         *   Bind the VoIP bidirectional module $bidir to this object $obj.
+         */
+    virtual int command (int argc, const char*const* argv);
+
+    //! Generate a new talkspurt.
+    void handle ();
+
+    //! Stops talkspurts generation
+    void stop () {
+        timer_.stop ();
+    }
+
+protected:
+    //! Timer to schedule talkspurts.
+    /*!
+        * The timer is first started via a Tcl command.
+        */
+    TTimer<VoipSource> timer_;
+    //! Pointer to the encoder application.
+    VoipEncoder* encoder_;
+
+    //! Pointer to the bidirectional module, if present.
+    VoipBidirectional* bidirectional_;
+
+    //! Random variable for talkspurt durations.
+    RandomVariable* talk_;
+
+    //! Random variable for silence durations.
+    RandomVariable* silence_;
+
+    WeibullRandomVariable talk1_;
+    WeibullRandomVariable silence1_;
+
+    //! Talkspurt counter.
+    unsigned int count_;
+    //! True if debug is enabled.
+    bool debug_;
+    bool stat_;
+    int fid_;
+};
+
+#endif // __NS2_VOIP_SOURCE_H